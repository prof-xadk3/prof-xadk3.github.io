(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.WebLN = {}));
})(this, (function (exports) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    /* tslint:disable:max-classes-per-file */
    /**
     * Workaround for custom errors when compiling typescript targeting 'ES5'.
     * see: https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work
     * @param {CustomError} error
     * @param newTarget the value of `new.target`
     * @param {Function} errorType
     */
    function fixError(error, newTarget, errorType) {
        Object.setPrototypeOf(error, errorType.prototype);
        // when an error constructor is invoked with the `new` operator
        if (newTarget === errorType) {
            error.name = newTarget.name;
            // exclude the constructor call of the error type from the stack trace.
            if (Error.captureStackTrace) {
                Error.captureStackTrace(error, errorType);
            }
            else {
                var stack = new Error(error.message).stack;
                if (stack) {
                    error.stack = fixStack(stack, "new ".concat(newTarget.name));
                }
            }
        }
    }
    function fixStack(stack, functionName) {
        if (!stack)
            return stack;
        if (!functionName)
            return stack;
        // exclude lines starts with:  "  at functionName "
        var exclusion = new RegExp("\\s+at\\s".concat(functionName, "\\s"));
        var lines = stack.split("\n");
        var resultLines = lines.filter(function (line) { return !line.match(exclusion); });
        return resultLines.join("\n");
    }
    /// CUSTOM ERRORS ///
    // When no WebLN provider is available
    var MissingProviderError = /** @class */ (function (_super) {
        __extends(MissingProviderError, _super);
        function MissingProviderError(message) {
            var _newTarget = this.constructor;
            var _this = _super.call(this, message) || this;
            fixError(_this, _newTarget, MissingProviderError);
            return _this;
        }
        return MissingProviderError;
    }(Error));
    // When the user rejects a request
    var RejectionError = /** @class */ (function (_super) {
        __extends(RejectionError, _super);
        function RejectionError(message) {
            var _newTarget = this.constructor;
            var _this = _super.call(this, message) || this;
            fixError(_this, _newTarget, RejectionError);
            return _this;
        }
        return RejectionError;
    }(Error));
    // When the node can't be connected to (i.e. the app did nothing wrong)
    var ConnectionError = /** @class */ (function (_super) {
        __extends(ConnectionError, _super);
        function ConnectionError(message) {
            var _newTarget = this.constructor;
            var _this = _super.call(this, message) || this;
            fixError(_this, _newTarget, ConnectionError);
            return _this;
        }
        return ConnectionError;
    }(Error));
    // The WebLN provider doesn't support this method
    var UnsupportedMethodError = /** @class */ (function (_super) {
        __extends(UnsupportedMethodError, _super);
        function UnsupportedMethodError(message) {
            var _newTarget = this.constructor;
            var _this = _super.call(this, message) || this;
            fixError(_this, _newTarget, UnsupportedMethodError);
            return _this;
        }
        return UnsupportedMethodError;
    }(Error));
    // The desired node couldn't be routed to
    var RoutingError = /** @class */ (function (_super) {
        __extends(RoutingError, _super);
        function RoutingError(message) {
            var _newTarget = this.constructor;
            var _this = _super.call(this, message) || this;
            fixError(_this, _newTarget, RoutingError);
            return _this;
        }
        return RoutingError;
    }(Error));
    // An argument passed was somehow invalid (e.g. malformed invoice)
    var InvalidDataError = /** @class */ (function (_super) {
        __extends(InvalidDataError, _super);
        function InvalidDataError(message) {
            var _newTarget = this.constructor;
            var _this = _super.call(this, message) || this;
            fixError(_this, _newTarget, InvalidDataError);
            return _this;
        }
        return InvalidDataError;
    }(Error));
    // Something broke in the WebLN provider internally, nothing to do with the app
    var InternalError = /** @class */ (function (_super) {
        __extends(InternalError, _super);
        function InternalError(message) {
            var _newTarget = this.constructor;
            var _this = _super.call(this, message) || this;
            fixError(_this, _newTarget, InternalError);
            return _this;
        }
        return InternalError;
    }(Error));

    function requestProvider(_) {
        return new Promise(function (resolve, reject) {
            if (typeof window === 'undefined') {
                return reject(new Error('Must be called in a browser context'));
            }
            var webln = window.webln;
            if (!webln) {
                return reject(new MissingProviderError('Your browser has no WebLN provider'));
            }
            webln.enable()
                .then(function () { return resolve(webln); })
                .catch(function (err) { return reject(err); });
        });
    }

    exports.ConnectionError = ConnectionError;
    exports.InternalError = InternalError;
    exports.InvalidDataError = InvalidDataError;
    exports.MissingProviderError = MissingProviderError;
    exports.RejectionError = RejectionError;
    exports.RoutingError = RoutingError;
    exports.UnsupportedMethodError = UnsupportedMethodError;
    exports.requestProvider = requestProvider;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
