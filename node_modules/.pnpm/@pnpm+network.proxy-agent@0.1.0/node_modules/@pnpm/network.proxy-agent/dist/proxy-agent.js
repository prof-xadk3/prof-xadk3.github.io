"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getProxyAgent = void 0;
const error_1 = require("@pnpm/error");
const agent_1 = __importDefault(require("https-proxy-agent/dist/agent"));
const http_proxy_agent_1 = __importDefault(require("http-proxy-agent"));
const socks_proxy_agent_1 = __importDefault(require("socks-proxy-agent"));
const lru_cache_1 = __importDefault(require("lru-cache"));
const DEFAULT_MAX_SOCKETS = 50;
const AGENT_CACHE = new lru_cache_1.default({ max: 50 });
function getProxyAgent(uri, opts) {
    var _a, _b, _c;
    const parsedUri = new URL(uri);
    const pxuri = getProxyUri(parsedUri, opts);
    if (!pxuri)
        return;
    const isHttps = parsedUri.protocol === 'https:';
    /* eslint-disable @typescript-eslint/prefer-nullish-coalescing */
    const key = [
        `https:${isHttps.toString()}`,
        `proxy:${pxuri.protocol}//${pxuri.username}:${pxuri.password}@${pxuri.host}:${pxuri.port}`,
        `local-address:${(_a = opts.localAddress) !== null && _a !== void 0 ? _a : '>no-local-address<'}`,
        `strict-ssl:${isHttps ? Boolean(opts.strictSsl).toString() : '>no-strict-ssl<'}`,
        `ca:${(isHttps && ((_b = opts.ca) === null || _b === void 0 ? void 0 : _b.toString())) || '>no-ca<'}`,
        `cert:${(isHttps && ((_c = opts.cert) === null || _c === void 0 ? void 0 : _c.toString())) || '>no-cert<'}`,
        `key:${(isHttps && opts.key) || '>no-key<'}`,
    ].join(':');
    /* eslint-enable @typescript-eslint/prefer-nullish-coalescing */
    if (AGENT_CACHE.peek(key)) {
        return AGENT_CACHE.get(key);
    }
    const proxy = getProxy(pxuri, opts, isHttps);
    AGENT_CACHE.set(key, proxy);
    return proxy;
}
exports.getProxyAgent = getProxyAgent;
function getProxyUri(uri, opts) {
    const { protocol } = uri;
    let proxy;
    switch (protocol) {
        case 'http:': {
            proxy = opts.httpProxy;
            break;
        }
        case 'https:': {
            proxy = opts.httpsProxy;
            break;
        }
    }
    if (!proxy) {
        return undefined;
    }
    if (!proxy.includes('://')) {
        proxy = `${protocol}//${proxy}`;
    }
    if (typeof proxy !== 'string') {
        return proxy;
    }
    try {
        return new URL(proxy);
    }
    catch (err) {
        throw new error_1.PnpmError('INVALID_PROXY', "Couldn't parse proxy URL", {
            hint: `If your proxy URL contains a username and password, make sure to URL-encode them (you may use the encodeURIComponent function). For instance, https-proxy=https://use%21r:pas%2As@my.proxy:1234/foo. Do not encode the colon (:) between the username and password.`,
        });
    }
}
function getProxy(proxyUrl, opts, isHttps) {
    var _a, _b;
    const popts = {
        auth: getAuth(proxyUrl),
        ca: opts.ca,
        cert: opts.cert,
        host: proxyUrl.hostname,
        key: opts.key,
        localAddress: opts.localAddress,
        maxSockets: (_a = opts.maxSockets) !== null && _a !== void 0 ? _a : DEFAULT_MAX_SOCKETS,
        path: proxyUrl.pathname,
        port: proxyUrl.port,
        protocol: proxyUrl.protocol,
        rejectUnauthorized: opts.strictSsl,
        timeout: typeof opts.timeout !== 'number' || opts.timeout === 0 ? 0 : opts.timeout + 1,
    };
    if (proxyUrl.protocol === 'http:' || proxyUrl.protocol === 'https:') {
        if (!isHttps) {
            return (0, http_proxy_agent_1.default)(popts);
        }
        else {
            return new PatchedHttpsProxyAgent(popts);
        }
    }
    if ((_b = proxyUrl.protocol) === null || _b === void 0 ? void 0 : _b.startsWith('socks')) {
        return (0, socks_proxy_agent_1.default)(popts);
    }
    return undefined;
}
function getAuth(user) {
    if (!user.username) {
        return undefined;
    }
    let auth = user.username;
    if (user.password) {
        auth += `:${user.password}`;
    }
    return decodeURIComponent(auth);
}
const extraOpts = Symbol('extra agent opts');
// This is a workaround for this issue: https://github.com/TooTallNate/node-https-proxy-agent/issues/89
class PatchedHttpsProxyAgent extends agent_1.default {
    constructor(opts) {
        super(opts);
        this[extraOpts] = opts;
    }
    callback(req, opts) {
        return super.callback(req, Object.assign(Object.assign({}, this[extraOpts]), opts));
    }
}
//# sourceMappingURL=proxy-agent.js.map