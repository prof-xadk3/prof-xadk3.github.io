import { Bot, Channel, Collection, DiscordGatewayPayload, Guild, Member, Message, Role, User } from "../../deps.js";
import { BotWithProxyEvents } from "./events.js";
declare const updateHandlers: () => {
    GUILD_LOADED_DD: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => void;
    READY: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    CHANNEL_CREATE: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    CHANNEL_DELETE: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    CHANNEL_PINS_UPDATE: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    CHANNEL_UPDATE: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    GUILD_AUDIT_LOG_ENTRY_CREATE: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    GUILD_BAN_ADD: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    GUILD_BAN_REMOVE: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    GUILD_CREATE: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    GUILD_DELETE: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    GUILD_EMOJIS_UPDATE: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    GUILD_INTEGRATIONS_UPDATE: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    GUILD_MEMBER_ADD: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    GUILD_MEMBER_REMOVE: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    GUILD_MEMBER_UPDATE: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    GUILD_MEMBERS_CHUNK: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    GUILD_ROLE_CREATE: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    GUILD_ROLE_DELETE: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    GUILD_ROLE_UPDATE: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    GUILD_UPDATE: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    GUILD_SCHEDULED_EVENT_CREATE: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    GUILD_SCHEDULED_EVENT_DELETE: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    GUILD_SCHEDULED_EVENT_UPDATE: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    GUILD_SCHEDULED_EVENT_USER_ADD: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    GUILD_SCHEDULED_EVENT_USER_REMOVE: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    INTERACTION_CREATE: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    INVITE_CREATE: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    INVITE_DELETE: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    MESSAGE_CREATE: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    MESSAGE_DELETE_BULK: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    MESSAGE_DELETE: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    MESSAGE_REACTION_ADD: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    MESSAGE_REACTION_REMOVE_ALL: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    MESSAGE_REACTION_REMOVE_EMOJI: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    MESSAGE_REACTION_REMOVE: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    MESSAGE_UPDATE: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    PRESENCE_UPDATE: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    TYPING_START: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    USER_UPDATE: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    VOICE_SERVER_UPDATE: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    VOICE_STATE_UPDATE: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    WEBHOOKS_UPDATE: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    INTEGRATION_CREATE: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    INTEGRATION_UPDATE: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    INTEGRATION_DELETE: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    STAGE_INSTANCE_CREATE: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    STAGE_INSTANCE_UPDATE: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    STAGE_INSTANCE_DELETE: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    THREAD_CREATE: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    THREAD_UPDATE: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    THREAD_DELETE: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    THREAD_LIST_SYNC: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
    THREAD_MEMBERS_UPDATE: (bot: Bot, data: DiscordGatewayPayload, shardId: number) => any;
};
export interface ProxyCacheProps<T extends ProxyCacheTypes> {
    handlers: ReturnType<typeof updateHandlers>;
    events: BotWithProxyEvents;
    cache: Bot["cache"] & {
        options: CreateProxyCacheOptions;
        guilds: {
            memory: Collection<bigint, T["guild"]>;
            /**
             * @param id Guild ID
             * @param fetch whether to fetch missing data
             */
            get: (id: bigint, fetch?: boolean) => Promise<T["guild"] | undefined>;
            set: (value: T["guild"]) => Promise<void>;
            delete: (id: bigint) => Promise<void>;
        };
        channels: {
            guildIDs: Collection<bigint, bigint>;
            memory: Collection<bigint, T["channel"]>;
            /**
             * @param id Channel ID
             * @param guildId Guild ID (Only required if option fetchIfMissing.channels is set to true)
             * @param fetch whether to fetch missing data
             */
            get: (id: bigint, guildID?: bigint, fetch?: boolean) => Promise<T["channel"] | undefined>;
            set: (value: T["channel"]) => Promise<void>;
            delete: (id: bigint) => Promise<void>;
        };
        roles: {
            guildIDs: Collection<bigint, bigint>;
            memory: Collection<bigint, T["role"]>;
            /**
             * @param id Role ID
             * @param guildId Guild ID (Only required if option fetchIfMissing.roles is set to true)
             * @param fetch whether to fetch missing data
             */
            get: (id: bigint, guildId?: bigint, fetch?: boolean) => Promise<T["role"] | undefined>;
            set: (value: T["role"]) => Promise<void>;
            delete: (id: bigint) => Promise<void>;
        };
        members: {
            memory: Collection<bigint, T["member"]>;
            /**
             * @param id Member ID
             * @param guildId Guild ID
             * @param fetch whether to fetch missing data
             */
            get: (id: bigint, guildId: bigint, fetch?: boolean) => Promise<T["member"] | undefined>;
            set: (value: T["member"]) => Promise<void>;
            delete: (id: bigint, guildId: bigint) => Promise<void>;
        };
        messages: {
            channelIDs: Collection<bigint, bigint>;
            memory: Collection<bigint, T["message"]>;
            /**
             * @param id Message ID
             * @param channelId Channel ID (Only required if option fetchIfMissing.messages is set to true)
             * @param guildId Guild ID (Only required if option fetchIfMissing.messages is set to true and you want to fetch a guild message)
             * @param fetch whether to fetch missing data
             */
            get: (id: bigint, channelId?: bigint, guildId?: bigint, fetch?: boolean) => Promise<T["message"] | undefined>;
            set: (value: T["message"]) => Promise<void>;
            delete: (id: bigint) => Promise<void>;
        };
        users: {
            memory: Collection<bigint, T["user"]>;
            /**
             * @param id User ID
             * @param fetch whether to fetch missing data
             */
            get: (id: bigint, fetch?: boolean) => Promise<T["user"] | undefined>;
            set: (value: T["user"]) => Promise<void>;
            delete: (id: bigint) => Promise<void>;
        };
    };
}
export type BotWithProxyCache<T extends ProxyCacheTypes, B extends Bot = Bot> = Omit<B, "cache"> & ProxyCacheProps<T>;
export declare function createProxyCache<T extends ProxyCacheTypes<boolean> = ProxyCacheTypes, B extends Bot = Bot>(rawBot: B, options: CreateProxyCacheOptions): BotWithProxyCache<T, B>;
export type ProxyCacheTypes<T extends boolean = true> = {
    guild: T extends true ? Guild : any;
    user: T extends true ? User : any;
    channel: T extends true ? Channel : any;
    member: T extends true ? Member : any;
    role: T extends true ? Role : any;
    message: T extends true ? Message : any;
};
export interface CreateProxyCacheOptions {
    /** Configure the handlers that should be ran whenever something is about to be cached to determine whether it should or should not be cached. */
    shouldCache?: {
        /** Handler to check whether or not to cache this guild. */
        guild?: (guild: Guild) => Promise<boolean>;
        /** Handler to check whether or not to cache this user. */
        user?: (user: User) => Promise<boolean>;
        /** Handler to check whether or not to cache this channel. */
        channel?: (channel: Channel) => Promise<boolean>;
        /** Handler to check whether or not to cache this member. */
        member?: (member: Member) => Promise<boolean>;
        /** Handler to check whether or not to cache this role. */
        role?: (role: Role) => Promise<boolean>;
        /** Handler to check whether or not to cache this message. */
        message?: (message: Message) => Promise<boolean>;
    };
    /** Configure the exact properties you wish to have in each object. */
    desiredProps?: {
        /** The properties you want to keep in a user object. */
        users?: (keyof User)[];
        /** The properties you want to keep in a guild object. */
        guilds?: (keyof Guild)[];
        /** The properties you want to keep in a channel object. */
        channels?: (keyof Channel)[];
        /** The properties you want to keep in a member object. */
        members?: (keyof Member)[];
        /** The properties you want to keep in a role object. */
        roles?: (keyof Role)[];
        /** The properties you want to keep in a message object. */
        messages?: (keyof Message)[];
    };
    /** Configure the properties you do NOT want in each object. */
    undesiredProps?: {
        /** The properties you do NOT want in a user object. */
        users?: (keyof User)[];
        /** The properties you do NOT want in a guild object. */
        guilds?: (keyof Guild)[];
        /** The properties you do NOT want in a channel object. */
        channels?: (keyof Channel)[];
        /** The properties you do NOT want in a member object. */
        members?: (keyof Member)[];
        /** The properties you do NOT want in a role object. */
        roles?: (keyof Role)[];
        /** The properties you do NOT want in a message object. */
        messages?: (keyof Message)[];
    };
    /** Options to choose how the proxy will cache everything.
     *
     * By default, all props inside `cacheInMemory` are set to `true`. */
    cacheInMemory?: {
        /** Whether or not to cache guilds. */
        guilds?: boolean;
        /** Whether or not to cache users. */
        users?: boolean;
        /** Whether or not to cache channels. If guilds is enabled, then these are cached inside the guild object. */
        channels?: boolean;
        /** Whether or not to cache members. If guilds is enabled, then these are cached inside the guild object. */
        members?: boolean;
        /** Whether or not the cache roles. If guilds is enabled, then these are cached inside the guild object.*/
        roles?: boolean;
        /** Whether or not the cache messages. If channels is enabled, then these are cached inside the channel object.*/
        messages?: boolean;
        /** Default value for the properties that are not provided inside `cacheInMemory`. */
        default: boolean;
    };
    /** Options to choose how the proxy will cache in a separate persitant cache.
     *
     * By default, all props inside `cacheOutsideMemory` are set to `false`. */
    cacheOutsideMemory?: {
        /** Whether or not to cache guilds. */
        guilds?: boolean;
        /** Whether or not to cache users. */
        users?: boolean;
        /** Whether or not to cache channels. */
        channels?: boolean;
        /** Whether or not to cache members. */
        members?: boolean;
        /** Whether or not to cache roles. */
        roles?: boolean;
        /** Whether or not to cache messages. */
        messages?: boolean;
        /** Default value for the properties that are not provided inside `cacheOutsideMemory`. */
        default: boolean;
    };
    /** Handler to get an object from a specific table. */
    getItem?: <T>(...args: [table: "guild" | "channel" | "role" | "message" | "user", id: bigint] | [table: "member", id: bigint, guildId: bigint]) => Promise<T>;
    /** Handler to set an object in a specific table. */
    setItem?: (table: "guild" | "channel" | "role" | "member" | "message" | "user", item: any) => Promise<unknown>;
    /** Handler to delete an object in a specific table. */
    removeItem?: (...args: [table: "guild" | "channel" | "role" | "message" | "user", id: bigint] | [table: "member", id: bigint, guildId: bigint]) => Promise<unknown>;
    bulk?: {
        /** Handler used to remove multiple objects in bulk. Instead of making hundreds of queries, you can optimize here using your preferred form. For example, when a guild is deleted, you want to make sure all channels, roles, messages and members are removed as well. */
        removeGuild?: (id: bigint) => Promise<unknown>;
        /** Handler used to remove multiple objects in bulk. Instead of making hundreds of queries, you can optimize here using your preferred form. For example, when a channel is deleted, you want to make sure all messages are removed as well. */
        removeChannel?: (id: bigint) => Promise<unknown>;
        /** Handler used to remove multiple objects in bulk. Instead of making hundreds of queries, you can optimize here using your preferred form. For example, when a role is deleted, you want to make sure all members who have this role are edited as well. */
        removeRole?: (id: bigint) => Promise<unknown>;
        /** Handler used to remove multiple messages. */
        removeMessages?: (ids: bigint[]) => Promise<unknown>;
        /** Options to choose whether or not to replace internal removers. */
        replaceInternalBulkRemover?: {
            /** Whether or not to replace internal guild remover.
             *
             * By default, the proxy will bulk remove guilds from memory. You can override this behavior by setting this option to `true`.
             */
            guild?: boolean;
            /** Whether or not to replace internal channel remover.
             *
             * By default, the proxy will bulk remove channel from memory. You can override this behavior by setting this option to `true`.
             */
            channel?: boolean;
            /** Whether or not to replace internal role remover.
             *
             * By default, the proxy will bulk remove role from memory. You can override this behavior by setting this option to `true`.
             */
            role?: boolean;
            /** Whether or not to replace internal message remover.
             *
             * By default, the proxy will bulk remove message from memory. You can override this behavior by setting this option to `true`.
             */
            messages?: boolean;
        };
    };
    /** Whether or not to fetch something if it's missing */
    fetchIfMissing?: {
        guilds?: boolean;
        users?: boolean;
        roles?: boolean;
        channels?: boolean;
        members?: boolean;
        messages?: boolean;
    };
}
declare module "../../deps.js" {
    interface Channel {
        /** The messages that are available in this channel. */
        messages: Collection<bigint, Message>;
    }
}
export {};
