"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResponseError = exports.fetch = exports.Response = exports.isRedirect = void 0;
const core_loggers_1 = require("@pnpm/core-loggers");
const retry_1 = require("@zkochan/retry");
const node_fetch_1 = __importStar(require("node-fetch"));
Object.defineProperty(exports, "Response", { enumerable: true, get: function () { return node_fetch_1.Response; } });
var node_fetch_2 = require("node-fetch");
Object.defineProperty(exports, "isRedirect", { enumerable: true, get: function () { return node_fetch_2.isRedirect; } });
const NO_RETRY_ERROR_CODES = new Set([
    'SELF_SIGNED_CERT_IN_CHAIN',
    'ERR_OSSL_PEM_NO_START_LINE',
]);
async function fetch(url, opts = {}) {
    const retryOpts = opts.retry ?? {};
    const maxRetries = retryOpts.retries ?? 2;
    const op = (0, retry_1.operation)({
        factor: retryOpts.factor ?? 10,
        maxTimeout: retryOpts.maxTimeout ?? 60000,
        minTimeout: retryOpts.minTimeout ?? 10000,
        randomize: false,
        retries: maxRetries,
    });
    try {
        return await new Promise((resolve, reject) => {
            op.attempt(async (attempt) => {
                try {
                    // this will be retried
                    const res = await (0, node_fetch_1.default)(url, opts); // eslint-disable-line
                    // A retry on 409 sometimes helps when making requests to the Bit registry.
                    if ((res.status >= 500 && res.status < 600) || [408, 409, 420, 429].includes(res.status)) {
                        throw new ResponseError(res);
                    }
                    else {
                        resolve(res);
                        return;
                    }
                }
                catch (error) { // eslint-disable-line
                    if (error.code && NO_RETRY_ERROR_CODES.has(error.code)) {
                        throw error;
                    }
                    const timeout = op.retry(error);
                    if (timeout === false) {
                        reject(op.mainError());
                        return;
                    }
                    core_loggers_1.requestRetryLogger.debug({
                        attempt,
                        error,
                        maxRetries,
                        method: opts.method ?? 'GET',
                        timeout,
                        url: url.toString(),
                    });
                }
            });
        });
    }
    catch (err) {
        if (err instanceof ResponseError) {
            return err.res;
        }
        throw err;
    }
}
exports.fetch = fetch;
class ResponseError extends Error {
    constructor(res) {
        super(res.statusText);
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, ResponseError);
        }
        this.name = this.constructor.name;
        this.res = res;
        // backward compat
        this.code = this.status = this.statusCode = res.status;
        this.url = res.url;
    }
}
exports.ResponseError = ResponseError;
//# sourceMappingURL=fetch.js.map