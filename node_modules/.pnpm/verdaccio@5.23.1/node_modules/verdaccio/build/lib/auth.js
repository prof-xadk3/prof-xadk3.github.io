"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _debug = _interopRequireDefault(require("debug"));
var _lodash = _interopRequireDefault(require("lodash"));
var _config = require("@verdaccio/config");
var _signature = require("@verdaccio/signature");
var _utils = require("@verdaccio/utils");
var _pluginLoader = _interopRequireDefault(require("../lib/plugin-loader"));
var _authUtils = require("./auth-utils");
var _constants = require("./constants");
var _logger = require("./logger");
var _utils2 = require("./utils");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const debug = (0, _debug.default)('verdaccio:auth');
class Auth {
  constructor(config) {
    _defineProperty(this, "config", void 0);
    _defineProperty(this, "logger", void 0);
    _defineProperty(this, "secret", void 0);
    _defineProperty(this, "plugins", void 0);
    this.config = config;
    this.logger = _logger.logger;
    this.secret = config.secret;
    this.plugins = this._loadPlugin(config);
    this._applyDefaultPlugins();
  }
  _loadPlugin(config) {
    const pluginOptions = {
      config,
      logger: this.logger
    };
    return (0, _pluginLoader.default)(config, config.auth, pluginOptions, plugin => {
      const {
        authenticate,
        allow_access,
        allow_publish
      } = plugin;
      // @ts-ignore
      return authenticate || allow_access || allow_publish;
    });
  }
  _applyDefaultPlugins() {
    this.plugins.push((0, _authUtils.getDefaultPlugins)(this.logger));
  }
  changePassword(username, password,
  // pragma: allowlist secret
  newPassword,
  // pragma: allowlist secret
  cb) {
    const validPlugins = _lodash.default.filter(this.plugins, plugin => _lodash.default.isFunction(plugin.changePassword));
    if (_lodash.default.isEmpty(validPlugins)) {
      return cb(_utils2.ErrorCode.getInternalError(_constants.SUPPORT_ERRORS.PLUGIN_MISSING_INTERFACE));
    }
    for (const plugin of validPlugins) {
      if (_lodash.default.isNil(plugin) || _lodash.default.isFunction(plugin.changePassword) === false) {
        debug('auth plugin does not implement changePassword, trying next one');
        continue;
      } else {
        debug('updating password for %o', username);
        plugin.changePassword(username, password, newPassword, (err, profile) => {
          if (err) {
            this.logger.error({
              username,
              err
            }, `An error has been produced
            updating the password for @{username}. Error: @{err.message}`);
            return cb(err);
          }
          this.logger.info({
            username
          }, 'updated password for @{username} was successful');
          return cb(null, profile);
        });
      }
    }
  }
  authenticate(username, password, cb) {
    const plugins = this.plugins.slice(0);
    const self = this;
    (function next() {
      const plugin = plugins.shift();
      if (_lodash.default.isFunction(plugin.authenticate) === false) {
        return next();
      }
      debug('authenticating %o', username);
      plugin.authenticate(username, password, function (err, groups) {
        if (err) {
          self.logger.error({
            username,
            err
          }, 'authenticating for user @{username} failed. Error: @{err.message}');
          return cb(err);
        }

        // Expect: SKIP if groups is falsey and not an array
        //         with at least one item (truthy length)
        // Expect: CONTINUE otherwise (will error if groups is not
        //         an array, but this is current behavior)
        // Caveat: STRING (if valid) will pass successfully
        //         bug give unexpected results
        // Info: Cannot use `== false to check falsey values`
        if (!!groups && groups.length !== 0) {
          // TODO: create a better understanding of expectations
          if (_lodash.default.isString(groups)) {
            throw new TypeError('plugin group error: invalid type for function');
          }
          const isGroupValid = _lodash.default.isArray(groups);
          if (!isGroupValid) {
            throw new TypeError(_constants.API_ERROR.BAD_FORMAT_USER_GROUP);
          }
          debug('authentication for user %o was successfully. Groups: %o', username, groups);
          return cb(err, (0, _config.createRemoteUser)(username, groups));
        }
        next();
      });
    })();
  }
  add_user(user, password, cb) {
    const self = this;
    const plugins = this.plugins.slice(0);
    debug('add user %o', user);
    (function next() {
      const plugin = plugins.shift();
      let method = 'adduser';
      if (_lodash.default.isFunction(plugin[method]) === false) {
        method = 'add_user';
        self.logger.warn('the plugin method add_user in the auth plugin is deprecated and will be removed in next major release, notify to the plugin author');
      }
      if (_lodash.default.isFunction(plugin[method]) === false) {
        next();
      } else {
        // p.add_user() execution
        plugin[method](user, password, function (err, ok) {
          if (err) {
            self.logger.error({
              user,
              err: err.message
            }, 'the user @{user} could not being added. Error: @{err}');
            return cb(err);
          }
          if (ok) {
            self.logger.info({
              user
            }, 'the user @{user} has been added');
            return self.authenticate(user, password, cb);
          }
          next();
        });
      }
    })();
  }

  /**
   * Allow user to access a package.
   */
  allow_access({
    packageName,
    packageVersion
  }, user, callback) {
    const plugins = this.plugins.slice(0);
    const self = this;
    const pkgAllowAcces = {
      name: packageName,
      version: packageVersion
    };
    const pkg = Object.assign({}, pkgAllowAcces, (0, _utils.getMatchedPackagesSpec)(packageName, this.config.packages));
    debug('allow access for %o', packageName);
    (function next() {
      const plugin = plugins.shift();
      if (_lodash.default.isNil(plugin) || _lodash.default.isFunction(plugin.allow_access) === false) {
        return next();
      }
      plugin.allow_access(user, pkg, function (err, ok) {
        if (err) {
          self.logger.error({
            packageName,
            err
          }, 'forbidden access for @{packageName}. Error: @{err.message}');
          return callback(err);
        }
        if (ok) {
          self.logger.info({
            packageName
          }, 'allowed access for @{packageName}');
          return callback(null, ok);
        }
        next(); // cb(null, false) causes next plugin to roll
      });
    })();
  }

  allow_unpublish({
    packageName,
    packageVersion
  }, user, callback) {
    const pkg = Object.assign({
      name: packageName,
      version: packageVersion
    }, (0, _utils.getMatchedPackagesSpec)(packageName, this.config.packages));
    debug('allow unpublish for %o', packageName);
    for (const plugin of this.plugins) {
      if (_lodash.default.isNil(plugin) || _lodash.default.isFunction(plugin.allow_unpublish) === false) {
        debug('allow unpublish for %o plugin does not implement allow_unpublish', packageName);
        continue;
      } else {
        // @ts-ignore
        plugin.allow_unpublish(user, pkg, (err, ok) => {
          if (err) {
            this.logger.error({
              packageName,
              user: user === null || user === void 0 ? void 0 : user.name
            }, '@{user} forbidden publish for @{packageName}, it will fallback on unpublish permissions');
            return callback(err);
          }
          if (_lodash.default.isNil(ok) === true) {
            debug('we bypass unpublish for %o, publish will handle the access', packageName);
            // @ts-ignore
            // eslint-disable-next-line
            return this.allow_publish(...arguments);
          }
          if (ok) {
            this.logger.info({
              packageName,
              user: user === null || user === void 0 ? void 0 : user.name
            }, '@{user} allowed unpublish for @{packageName}');
            return callback(null, ok);
          }
        });
      }
    }
  }

  /**
   * Allow user to publish a package.
   */
  allow_publish({
    packageName,
    packageVersion
  }, user, callback) {
    const plugins = this.plugins.slice(0);
    const self = this;
    const pkg = Object.assign({
      name: packageName,
      version: packageVersion
    }, (0, _utils.getMatchedPackagesSpec)(packageName, this.config.packages));
    debug('allow publish for %o init | plugins: %o', packageName, plugins);
    (function next() {
      const plugin = plugins.shift();
      if (_lodash.default.isNil(plugin) || _lodash.default.isFunction(plugin.allow_publish) === false) {
        debug('allow publish for %o plugin does not implement allow_publish', packageName);
        return next();
      }

      // @ts-ignore
      plugin.allow_publish(user, pkg, (err, ok) => {
        if (_lodash.default.isNil(err) === false && _lodash.default.isError(err)) {
          self.logger.error({
            packageName,
            user: user === null || user === void 0 ? void 0 : user.name
          }, '@{user} is forbidden publish for @{packageName}');
          return callback(err);
        }
        if (ok) {
          self.logger.info({
            packageName,
            user: user === null || user === void 0 ? void 0 : user.name
          }, '@{user} is allowed publish for @{packageName}');
          return callback(null, ok);
        }
        debug('allow publish skip validation for %o', packageName);
        next(); // cb(null, false) causes next plugin to roll
      });
    })();
  }

  apiJWTmiddleware() {
    const plugins = this.plugins.slice(0);
    const helpers = {
      createAnonymousRemoteUser: _config.createAnonymousRemoteUser,
      createRemoteUser: _config.createRemoteUser
    };
    for (const plugin of plugins) {
      if (plugin.apiJWTmiddleware) {
        return plugin.apiJWTmiddleware(helpers);
      }
    }
    return (req, res, _next) => {
      req.pause();
      const next = function (err) {
        req.resume();
        // uncomment this to reject users with bad auth headers
        // return _next.apply(null, arguments)
        // swallow error, user remains unauthorized
        // set remoteUserError to indicate that user was attempting authentication
        if (err) {
          req.remote_user.error = err.message;
        }
        return _next();
      };
      if (this._isRemoteUserValid(req.remote_user)) {
        // @ts-ignore
        return next();
      }

      // in case auth header does not exist we return anonymous function
      req.remote_user = (0, _config.createAnonymousRemoteUser)();
      const {
        authorization
      } = req.headers;
      if (_lodash.default.isNil(authorization)) {
        // @ts-ignore
        return next();
      }
      if (!(0, _authUtils.isAuthHeaderValid)(authorization)) {
        debug('api middleware auth heather is not valid');
        return next(_utils2.ErrorCode.getBadRequest(_constants.API_ERROR.BAD_AUTH_HEADER));
      }
      const security = (0, _authUtils.getSecurity)(this.config);
      const {
        secret
      } = this.config;
      if ((0, _authUtils.isAESLegacy)(security)) {
        debug('api middleware using legacy auth token');
        this._handleAESMiddleware(req, security, secret, authorization, next);
      } else {
        debug('api middleware using JWT auth token');
        this._handleJWTAPIMiddleware(req, security, secret, authorization, next);
      }
    };
  }
  _handleJWTAPIMiddleware(req, security, secret, authorization, next) {
    const {
      scheme,
      token
    } = (0, _authUtils.parseAuthTokenHeader)(authorization);
    if (scheme.toUpperCase() === _constants.TOKEN_BASIC.toUpperCase()) {
      // this should happen when client tries to login with an existing user
      const credentials = (0, _utils2.convertPayloadToBase64)(token).toString();
      const {
        user,
        password
      } = (0, _authUtils.parseBasicPayload)(credentials);
      this.authenticate(user, password, (err, user) => {
        if (!err) {
          req.remote_user = user;
          next();
        } else {
          req.remote_user = (0, _config.createAnonymousRemoteUser)();
          next(err);
        }
      });
    } else {
      // jwt handler
      const credentials = (0, _authUtils.getMiddlewareCredentials)(security, secret, authorization);
      if (credentials) {
        // if the signature is valid we rely on it
        req.remote_user = credentials;
        next();
      } else {
        // with JWT throw 401
        next(_utils2.ErrorCode.getForbidden(_constants.API_ERROR.BAD_USERNAME_PASSWORD));
      }
    }
  }
  _handleAESMiddleware(req, security, secret, authorization, next) {
    const credentials = (0, _authUtils.getMiddlewareCredentials)(security, secret, authorization);
    if (credentials) {
      const {
        user,
        password
      } = credentials;
      this.authenticate(user, password, (err, user) => {
        if (!err) {
          req.remote_user = user;
          next();
        } else {
          req.remote_user = (0, _config.createAnonymousRemoteUser)();
          next(err);
        }
      });
    } else {
      // we force npm client to ask again with basic authentication
      return next(_utils2.ErrorCode.getBadRequest(_constants.API_ERROR.BAD_AUTH_HEADER));
    }
  }
  _isRemoteUserValid(remote_user) {
    return _lodash.default.isUndefined(remote_user) === false && _lodash.default.isUndefined(remote_user.name) === false;
  }

  /**
   * JWT middleware for WebUI
   */
  webUIJWTmiddleware() {
    return (req, res, _next) => {
      if (this._isRemoteUserValid(req.remote_user)) {
        return _next();
      }
      req.pause();
      const next = err => {
        req.resume();
        if (err) {
          // req.remote_user.error = err.message;
          res.status(err.statusCode).send(err.message);
        }
        return _next();
      };
      const {
        authorization
      } = req.headers;
      if (_lodash.default.isNil(authorization)) {
        // @ts-ignore
        return next();
      }
      if (!(0, _authUtils.isAuthHeaderValid)(authorization)) {
        return next(_utils2.ErrorCode.getBadRequest(_constants.API_ERROR.BAD_AUTH_HEADER));
      }
      const token = (authorization || '').replace(`${_constants.TOKEN_BEARER} `, '');
      if (!token) {
        // @ts-ignore
        return next();
      }
      let credentials;
      try {
        credentials = (0, _authUtils.verifyJWTPayload)(token, this.config.secret);
      } catch (err) {
        // FIXME: intended behaviour, do we want it?
      }
      if (this._isRemoteUserValid(credentials)) {
        const {
          name,
          groups
        } = credentials;
        req.remote_user = (0, _config.createRemoteUser)(name, groups);
      } else {
        req.remote_user = (0, _config.createAnonymousRemoteUser)();
      }
      // @ts-ignore
      next();
    };
  }
  async jwtEncrypt(user, signOptions) {
    const {
      real_groups,
      name,
      groups
    } = user;
    const realGroupsValidated = _lodash.default.isNil(real_groups) ? [] : real_groups;
    const groupedGroups = _lodash.default.isNil(groups) ? real_groups : Array.from(new Set([...groups.concat(realGroupsValidated)]));
    const payload = {
      real_groups: realGroupsValidated,
      name,
      groups: groupedGroups
    };
    const token = await (0, _signature.signPayload)(payload, this.secret, signOptions);
    return token;
  }

  /**
   * Encrypt a string.
   */
  aesEncrypt(buf) {
    return (0, _signature.aesEncryptDeprecated)(buf, this.secret);
  }
}
var _default = Auth;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfZGVidWciLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIl9sb2Rhc2giLCJfY29uZmlnIiwiX3NpZ25hdHVyZSIsIl91dGlscyIsIl9wbHVnaW5Mb2FkZXIiLCJfYXV0aFV0aWxzIiwiX2NvbnN0YW50cyIsIl9sb2dnZXIiLCJfdXRpbHMyIiwib2JqIiwiX19lc01vZHVsZSIsImRlZmF1bHQiLCJfZGVmaW5lUHJvcGVydHkiLCJrZXkiLCJ2YWx1ZSIsIl90b1Byb3BlcnR5S2V5IiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJhcmciLCJfdG9QcmltaXRpdmUiLCJTdHJpbmciLCJpbnB1dCIsImhpbnQiLCJwcmltIiwiU3ltYm9sIiwidG9QcmltaXRpdmUiLCJ1bmRlZmluZWQiLCJyZXMiLCJjYWxsIiwiVHlwZUVycm9yIiwiTnVtYmVyIiwiZGVidWciLCJidWlsZERlYnVnIiwiQXV0aCIsImNvbnN0cnVjdG9yIiwiY29uZmlnIiwibG9nZ2VyIiwic2VjcmV0IiwicGx1Z2lucyIsIl9sb2FkUGx1Z2luIiwiX2FwcGx5RGVmYXVsdFBsdWdpbnMiLCJwbHVnaW5PcHRpb25zIiwibG9hZFBsdWdpbiIsImF1dGgiLCJwbHVnaW4iLCJhdXRoZW50aWNhdGUiLCJhbGxvd19hY2Nlc3MiLCJhbGxvd19wdWJsaXNoIiwicHVzaCIsImdldERlZmF1bHRQbHVnaW5zIiwiY2hhbmdlUGFzc3dvcmQiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwibmV3UGFzc3dvcmQiLCJjYiIsInZhbGlkUGx1Z2lucyIsIl8iLCJmaWx0ZXIiLCJpc0Z1bmN0aW9uIiwiaXNFbXB0eSIsIkVycm9yQ29kZSIsImdldEludGVybmFsRXJyb3IiLCJTVVBQT1JUX0VSUk9SUyIsIlBMVUdJTl9NSVNTSU5HX0lOVEVSRkFDRSIsImlzTmlsIiwiZXJyIiwicHJvZmlsZSIsImVycm9yIiwiaW5mbyIsInNsaWNlIiwic2VsZiIsIm5leHQiLCJzaGlmdCIsImdyb3VwcyIsImxlbmd0aCIsImlzU3RyaW5nIiwiaXNHcm91cFZhbGlkIiwiaXNBcnJheSIsIkFQSV9FUlJPUiIsIkJBRF9GT1JNQVRfVVNFUl9HUk9VUCIsImNyZWF0ZVJlbW90ZVVzZXIiLCJhZGRfdXNlciIsInVzZXIiLCJtZXRob2QiLCJ3YXJuIiwib2siLCJtZXNzYWdlIiwicGFja2FnZU5hbWUiLCJwYWNrYWdlVmVyc2lvbiIsImNhbGxiYWNrIiwicGtnQWxsb3dBY2NlcyIsIm5hbWUiLCJ2ZXJzaW9uIiwicGtnIiwiYXNzaWduIiwiZ2V0TWF0Y2hlZFBhY2thZ2VzU3BlYyIsInBhY2thZ2VzIiwiYWxsb3dfdW5wdWJsaXNoIiwiYXJndW1lbnRzIiwiaXNFcnJvciIsImFwaUpXVG1pZGRsZXdhcmUiLCJoZWxwZXJzIiwiY3JlYXRlQW5vbnltb3VzUmVtb3RlVXNlciIsInJlcSIsIl9uZXh0IiwicGF1c2UiLCJyZXN1bWUiLCJyZW1vdGVfdXNlciIsIl9pc1JlbW90ZVVzZXJWYWxpZCIsImF1dGhvcml6YXRpb24iLCJoZWFkZXJzIiwiaXNBdXRoSGVhZGVyVmFsaWQiLCJnZXRCYWRSZXF1ZXN0IiwiQkFEX0FVVEhfSEVBREVSIiwic2VjdXJpdHkiLCJnZXRTZWN1cml0eSIsImlzQUVTTGVnYWN5IiwiX2hhbmRsZUFFU01pZGRsZXdhcmUiLCJfaGFuZGxlSldUQVBJTWlkZGxld2FyZSIsInNjaGVtZSIsInRva2VuIiwicGFyc2VBdXRoVG9rZW5IZWFkZXIiLCJ0b1VwcGVyQ2FzZSIsIlRPS0VOX0JBU0lDIiwiY3JlZGVudGlhbHMiLCJjb252ZXJ0UGF5bG9hZFRvQmFzZTY0IiwidG9TdHJpbmciLCJwYXJzZUJhc2ljUGF5bG9hZCIsImdldE1pZGRsZXdhcmVDcmVkZW50aWFscyIsImdldEZvcmJpZGRlbiIsIkJBRF9VU0VSTkFNRV9QQVNTV09SRCIsImlzVW5kZWZpbmVkIiwid2ViVUlKV1RtaWRkbGV3YXJlIiwic3RhdHVzIiwic3RhdHVzQ29kZSIsInNlbmQiLCJyZXBsYWNlIiwiVE9LRU5fQkVBUkVSIiwidmVyaWZ5SldUUGF5bG9hZCIsImp3dEVuY3J5cHQiLCJzaWduT3B0aW9ucyIsInJlYWxfZ3JvdXBzIiwicmVhbEdyb3Vwc1ZhbGlkYXRlZCIsImdyb3VwZWRHcm91cHMiLCJBcnJheSIsImZyb20iLCJTZXQiLCJjb25jYXQiLCJwYXlsb2FkIiwic2lnblBheWxvYWQiLCJhZXNFbmNyeXB0IiwiYnVmIiwiX2RlZmF1bHQiLCJleHBvcnRzIl0sInNvdXJjZXMiOlsiLi4vLi4vc3JjL2xpYi9hdXRoLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBidWlsZERlYnVnIGZyb20gJ2RlYnVnJztcbmltcG9ydCB7IE5leHRGdW5jdGlvbiB9IGZyb20gJ2V4cHJlc3MnO1xuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcblxuaW1wb3J0IHsgY3JlYXRlQW5vbnltb3VzUmVtb3RlVXNlciwgY3JlYXRlUmVtb3RlVXNlciB9IGZyb20gJ0B2ZXJkYWNjaW8vY29uZmlnJztcbmltcG9ydCB7IFZlcmRhY2Npb0Vycm9yLCBwbHVnaW5VdGlscyB9IGZyb20gJ0B2ZXJkYWNjaW8vY29yZSc7XG5pbXBvcnQgeyBhZXNFbmNyeXB0RGVwcmVjYXRlZCBhcyBhZXNFbmNyeXB0LCBzaWduUGF5bG9hZCB9IGZyb20gJ0B2ZXJkYWNjaW8vc2lnbmF0dXJlJztcbmltcG9ydCB7XG4gIEFsbG93QWNjZXNzLFxuICBDYWxsYmFjayxcbiAgQ29uZmlnLFxuICBKV1RTaWduT3B0aW9ucyxcbiAgTG9nZ2VyLFxuICBQYWNrYWdlQWNjZXNzLFxuICBSZW1vdGVVc2VyLFxuICBTZWN1cml0eSxcbn0gZnJvbSAnQHZlcmRhY2Npby90eXBlcyc7XG5pbXBvcnQgeyBnZXRNYXRjaGVkUGFja2FnZXNTcGVjIH0gZnJvbSAnQHZlcmRhY2Npby91dGlscyc7XG5cbmltcG9ydCBsb2FkUGx1Z2luIGZyb20gJy4uL2xpYi9wbHVnaW4tbG9hZGVyJztcbmltcG9ydCB7ICRSZXF1ZXN0RXh0ZW5kLCAkUmVzcG9uc2VFeHRlbmQsIEFFU1BheWxvYWQgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQge1xuICBnZXREZWZhdWx0UGx1Z2lucyxcbiAgZ2V0TWlkZGxld2FyZUNyZWRlbnRpYWxzLFxuICBnZXRTZWN1cml0eSxcbiAgaXNBRVNMZWdhY3ksXG4gIGlzQXV0aEhlYWRlclZhbGlkLFxuICBwYXJzZUF1dGhUb2tlbkhlYWRlcixcbiAgcGFyc2VCYXNpY1BheWxvYWQsXG4gIHZlcmlmeUpXVFBheWxvYWQsXG59IGZyb20gJy4vYXV0aC11dGlscyc7XG5pbXBvcnQgeyBBUElfRVJST1IsIFNVUFBPUlRfRVJST1JTLCBUT0tFTl9CQVNJQywgVE9LRU5fQkVBUkVSIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi9sb2dnZXInO1xuaW1wb3J0IHsgRXJyb3JDb2RlLCBjb252ZXJ0UGF5bG9hZFRvQmFzZTY0IH0gZnJvbSAnLi91dGlscyc7XG5cbmNvbnN0IGRlYnVnID0gYnVpbGREZWJ1ZygndmVyZGFjY2lvOmF1dGgnKTtcblxuY2xhc3MgQXV0aCB7XG4gIHB1YmxpYyBjb25maWc6IENvbmZpZztcbiAgcHVibGljIGxvZ2dlcjogTG9nZ2VyO1xuICBwdWJsaWMgc2VjcmV0OiBzdHJpbmc7XG4gIHB1YmxpYyBwbHVnaW5zOiBwbHVnaW5VdGlscy5BdXRoPENvbmZpZz5bXTtcblxuICBwdWJsaWMgY29uc3RydWN0b3IoY29uZmlnOiBDb25maWcpIHtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICB0aGlzLnNlY3JldCA9IGNvbmZpZy5zZWNyZXQ7XG4gICAgdGhpcy5wbHVnaW5zID0gdGhpcy5fbG9hZFBsdWdpbihjb25maWcpO1xuICAgIHRoaXMuX2FwcGx5RGVmYXVsdFBsdWdpbnMoKTtcbiAgfVxuXG4gIHByaXZhdGUgX2xvYWRQbHVnaW4oY29uZmlnOiBDb25maWcpOiBwbHVnaW5VdGlscy5BdXRoPENvbmZpZz5bXSB7XG4gICAgY29uc3QgcGx1Z2luT3B0aW9ucyA9IHtcbiAgICAgIGNvbmZpZyxcbiAgICAgIGxvZ2dlcjogdGhpcy5sb2dnZXIsXG4gICAgfTtcblxuICAgIHJldHVybiBsb2FkUGx1Z2luPHBsdWdpblV0aWxzLkF1dGg8Q29uZmlnPj4oXG4gICAgICBjb25maWcsXG4gICAgICBjb25maWcuYXV0aCxcbiAgICAgIHBsdWdpbk9wdGlvbnMsXG4gICAgICAocGx1Z2luOiBwbHVnaW5VdGlscy5BdXRoPENvbmZpZz4pOiBib29sZWFuID0+IHtcbiAgICAgICAgY29uc3QgeyBhdXRoZW50aWNhdGUsIGFsbG93X2FjY2VzcywgYWxsb3dfcHVibGlzaCB9ID0gcGx1Z2luO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiBhdXRoZW50aWNhdGUgfHwgYWxsb3dfYWNjZXNzIHx8IGFsbG93X3B1Ymxpc2g7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgX2FwcGx5RGVmYXVsdFBsdWdpbnMoKTogdm9pZCB7XG4gICAgdGhpcy5wbHVnaW5zLnB1c2goZ2V0RGVmYXVsdFBsdWdpbnModGhpcy5sb2dnZXIpKTtcbiAgfVxuXG4gIHB1YmxpYyBjaGFuZ2VQYXNzd29yZChcbiAgICB1c2VybmFtZTogc3RyaW5nLFxuICAgIHBhc3N3b3JkOiBzdHJpbmcsIC8vIHByYWdtYTogYWxsb3dsaXN0IHNlY3JldFxuICAgIG5ld1Bhc3N3b3JkOiBzdHJpbmcsIC8vIHByYWdtYTogYWxsb3dsaXN0IHNlY3JldFxuICAgIGNiOiBDYWxsYmFja1xuICApOiB2b2lkIHtcbiAgICBjb25zdCB2YWxpZFBsdWdpbnMgPSBfLmZpbHRlcih0aGlzLnBsdWdpbnMsIChwbHVnaW4pID0+IF8uaXNGdW5jdGlvbihwbHVnaW4uY2hhbmdlUGFzc3dvcmQpKTtcblxuICAgIGlmIChfLmlzRW1wdHkodmFsaWRQbHVnaW5zKSkge1xuICAgICAgcmV0dXJuIGNiKEVycm9yQ29kZS5nZXRJbnRlcm5hbEVycm9yKFNVUFBPUlRfRVJST1JTLlBMVUdJTl9NSVNTSU5HX0lOVEVSRkFDRSkpO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgcGx1Z2luIG9mIHZhbGlkUGx1Z2lucykge1xuICAgICAgaWYgKF8uaXNOaWwocGx1Z2luKSB8fCBfLmlzRnVuY3Rpb24ocGx1Z2luLmNoYW5nZVBhc3N3b3JkKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgZGVidWcoJ2F1dGggcGx1Z2luIGRvZXMgbm90IGltcGxlbWVudCBjaGFuZ2VQYXNzd29yZCwgdHJ5aW5nIG5leHQgb25lJyk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVidWcoJ3VwZGF0aW5nIHBhc3N3b3JkIGZvciAlbycsIHVzZXJuYW1lKTtcbiAgICAgICAgcGx1Z2luLmNoYW5nZVBhc3N3b3JkISh1c2VybmFtZSwgcGFzc3dvcmQsIG5ld1Bhc3N3b3JkLCAoZXJyLCBwcm9maWxlKTogdm9pZCA9PiB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXG4gICAgICAgICAgICAgIHsgdXNlcm5hbWUsIGVyciB9LFxuICAgICAgICAgICAgICBgQW4gZXJyb3IgaGFzIGJlZW4gcHJvZHVjZWRcbiAgICAgICAgICAgIHVwZGF0aW5nIHRoZSBwYXNzd29yZCBmb3IgQHt1c2VybmFtZX0uIEVycm9yOiBAe2Vyci5tZXNzYWdlfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gY2IoZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyh7IHVzZXJuYW1lIH0sICd1cGRhdGVkIHBhc3N3b3JkIGZvciBAe3VzZXJuYW1lfSB3YXMgc3VjY2Vzc2Z1bCcpO1xuICAgICAgICAgIHJldHVybiBjYihudWxsLCBwcm9maWxlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGF1dGhlbnRpY2F0ZSh1c2VybmFtZTogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nLCBjYjogQ2FsbGJhY2spOiB2b2lkIHtcbiAgICBjb25zdCBwbHVnaW5zID0gdGhpcy5wbHVnaW5zLnNsaWNlKDApO1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIChmdW5jdGlvbiBuZXh0KCk6IHZvaWQge1xuICAgICAgY29uc3QgcGx1Z2luID0gcGx1Z2lucy5zaGlmdCgpIGFzIHBsdWdpblV0aWxzLkF1dGg8Q29uZmlnPjtcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24ocGx1Z2luLmF1dGhlbnRpY2F0ZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICB9XG4gICAgICBkZWJ1ZygnYXV0aGVudGljYXRpbmcgJW8nLCB1c2VybmFtZSk7XG4gICAgICBwbHVnaW4uYXV0aGVudGljYXRlKHVzZXJuYW1lLCBwYXNzd29yZCwgZnVuY3Rpb24gKGVyciwgZ3JvdXBzKTogdm9pZCB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBzZWxmLmxvZ2dlci5lcnJvcihcbiAgICAgICAgICAgIHsgdXNlcm5hbWUsIGVyciB9LFxuICAgICAgICAgICAgJ2F1dGhlbnRpY2F0aW5nIGZvciB1c2VyIEB7dXNlcm5hbWV9IGZhaWxlZC4gRXJyb3I6IEB7ZXJyLm1lc3NhZ2V9J1xuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFeHBlY3Q6IFNLSVAgaWYgZ3JvdXBzIGlzIGZhbHNleSBhbmQgbm90IGFuIGFycmF5XG4gICAgICAgIC8vICAgICAgICAgd2l0aCBhdCBsZWFzdCBvbmUgaXRlbSAodHJ1dGh5IGxlbmd0aClcbiAgICAgICAgLy8gRXhwZWN0OiBDT05USU5VRSBvdGhlcndpc2UgKHdpbGwgZXJyb3IgaWYgZ3JvdXBzIGlzIG5vdFxuICAgICAgICAvLyAgICAgICAgIGFuIGFycmF5LCBidXQgdGhpcyBpcyBjdXJyZW50IGJlaGF2aW9yKVxuICAgICAgICAvLyBDYXZlYXQ6IFNUUklORyAoaWYgdmFsaWQpIHdpbGwgcGFzcyBzdWNjZXNzZnVsbHlcbiAgICAgICAgLy8gICAgICAgICBidWcgZ2l2ZSB1bmV4cGVjdGVkIHJlc3VsdHNcbiAgICAgICAgLy8gSW5mbzogQ2Fubm90IHVzZSBgPT0gZmFsc2UgdG8gY2hlY2sgZmFsc2V5IHZhbHVlc2BcbiAgICAgICAgaWYgKCEhZ3JvdXBzICYmIGdyb3Vwcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAvLyBUT0RPOiBjcmVhdGUgYSBiZXR0ZXIgdW5kZXJzdGFuZGluZyBvZiBleHBlY3RhdGlvbnNcbiAgICAgICAgICBpZiAoXy5pc1N0cmluZyhncm91cHMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwbHVnaW4gZ3JvdXAgZXJyb3I6IGludmFsaWQgdHlwZSBmb3IgZnVuY3Rpb24nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgaXNHcm91cFZhbGlkOiBib29sZWFuID0gXy5pc0FycmF5KGdyb3Vwcyk7XG4gICAgICAgICAgaWYgKCFpc0dyb3VwVmFsaWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoQVBJX0VSUk9SLkJBRF9GT1JNQVRfVVNFUl9HUk9VUCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlYnVnKCdhdXRoZW50aWNhdGlvbiBmb3IgdXNlciAlbyB3YXMgc3VjY2Vzc2Z1bGx5LiBHcm91cHM6ICVvJywgdXNlcm5hbWUsIGdyb3Vwcyk7XG4gICAgICAgICAgcmV0dXJuIGNiKGVyciwgY3JlYXRlUmVtb3RlVXNlcih1c2VybmFtZSwgZ3JvdXBzKSk7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dCgpO1xuICAgICAgfSk7XG4gICAgfSkoKTtcbiAgfVxuXG4gIHB1YmxpYyBhZGRfdXNlcih1c2VyOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcsIGNiOiBDYWxsYmFjayk6IHZvaWQge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGNvbnN0IHBsdWdpbnMgPSB0aGlzLnBsdWdpbnMuc2xpY2UoMCk7XG4gICAgZGVidWcoJ2FkZCB1c2VyICVvJywgdXNlcik7XG4gICAgKGZ1bmN0aW9uIG5leHQoKTogdm9pZCB7XG4gICAgICBjb25zdCBwbHVnaW4gPSBwbHVnaW5zLnNoaWZ0KCkgYXMgcGx1Z2luVXRpbHMuQXV0aDxDb25maWc+O1xuICAgICAgbGV0IG1ldGhvZCA9ICdhZGR1c2VyJztcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24ocGx1Z2luW21ldGhvZF0pID09PSBmYWxzZSkge1xuICAgICAgICBtZXRob2QgPSAnYWRkX3VzZXInO1xuICAgICAgICBzZWxmLmxvZ2dlci53YXJuKFxuICAgICAgICAgICd0aGUgcGx1Z2luIG1ldGhvZCBhZGRfdXNlciBpbiB0aGUgYXV0aCBwbHVnaW4gaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIG5leHQgbWFqb3IgcmVsZWFzZSwgbm90aWZ5IHRvIHRoZSBwbHVnaW4gYXV0aG9yJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKHBsdWdpblttZXRob2RdKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcC5hZGRfdXNlcigpIGV4ZWN1dGlvblxuICAgICAgICBwbHVnaW5bbWV0aG9kXSh1c2VyLCBwYXNzd29yZCwgZnVuY3Rpb24gKGVyciwgb2spOiB2b2lkIHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBzZWxmLmxvZ2dlci5lcnJvcihcbiAgICAgICAgICAgICAgeyB1c2VyLCBlcnI6IGVyci5tZXNzYWdlIH0sXG4gICAgICAgICAgICAgICd0aGUgdXNlciBAe3VzZXJ9IGNvdWxkIG5vdCBiZWluZyBhZGRlZC4gRXJyb3I6IEB7ZXJyfSdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gY2IoZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9rKSB7XG4gICAgICAgICAgICBzZWxmLmxvZ2dlci5pbmZvKHsgdXNlciB9LCAndGhlIHVzZXIgQHt1c2VyfSBoYXMgYmVlbiBhZGRlZCcpO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuYXV0aGVudGljYXRlKHVzZXIsIHBhc3N3b3JkLCBjYik7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGxvdyB1c2VyIHRvIGFjY2VzcyBhIHBhY2thZ2UuXG4gICAqL1xuICBwdWJsaWMgYWxsb3dfYWNjZXNzKFxuICAgIHsgcGFja2FnZU5hbWUsIHBhY2thZ2VWZXJzaW9uIH06IHBsdWdpblV0aWxzLkF1dGhQbHVnaW5QYWNrYWdlLFxuICAgIHVzZXI6IFJlbW90ZVVzZXIsXG4gICAgY2FsbGJhY2s6IENhbGxiYWNrXG4gICk6IHZvaWQge1xuICAgIGNvbnN0IHBsdWdpbnMgPSB0aGlzLnBsdWdpbnMuc2xpY2UoMCk7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgY29uc3QgcGtnQWxsb3dBY2NlczogQWxsb3dBY2Nlc3MgPSB7IG5hbWU6IHBhY2thZ2VOYW1lLCB2ZXJzaW9uOiBwYWNrYWdlVmVyc2lvbiB9O1xuICAgIGNvbnN0IHBrZyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICB7fSxcbiAgICAgIHBrZ0FsbG93QWNjZXMsXG4gICAgICBnZXRNYXRjaGVkUGFja2FnZXNTcGVjKHBhY2thZ2VOYW1lLCB0aGlzLmNvbmZpZy5wYWNrYWdlcylcbiAgICApIGFzIEFsbG93QWNjZXNzICYgUGFja2FnZUFjY2VzcztcbiAgICBkZWJ1ZygnYWxsb3cgYWNjZXNzIGZvciAlbycsIHBhY2thZ2VOYW1lKTtcblxuICAgIChmdW5jdGlvbiBuZXh0KCk6IHZvaWQge1xuICAgICAgY29uc3QgcGx1Z2luOiBwbHVnaW5VdGlscy5BdXRoPHVua25vd24+ID0gcGx1Z2lucy5zaGlmdCgpIGFzIHBsdWdpblV0aWxzLkF1dGg8Q29uZmlnPjtcblxuICAgICAgaWYgKF8uaXNOaWwocGx1Z2luKSB8fCBfLmlzRnVuY3Rpb24ocGx1Z2luLmFsbG93X2FjY2VzcykgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICB9XG5cbiAgICAgIHBsdWdpbi5hbGxvd19hY2Nlc3MhKHVzZXIsIHBrZywgZnVuY3Rpb24gKGVycjogVmVyZGFjY2lvRXJyb3IgfCBudWxsLCBvaz86IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHNlbGYubG9nZ2VyLmVycm9yKFxuICAgICAgICAgICAgeyBwYWNrYWdlTmFtZSwgZXJyIH0sXG4gICAgICAgICAgICAnZm9yYmlkZGVuIGFjY2VzcyBmb3IgQHtwYWNrYWdlTmFtZX0uIEVycm9yOiBAe2Vyci5tZXNzYWdlfSdcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9rKSB7XG4gICAgICAgICAgc2VsZi5sb2dnZXIuaW5mbyh7IHBhY2thZ2VOYW1lIH0sICdhbGxvd2VkIGFjY2VzcyBmb3IgQHtwYWNrYWdlTmFtZX0nKTtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgb2spO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV4dCgpOyAvLyBjYihudWxsLCBmYWxzZSkgY2F1c2VzIG5leHQgcGx1Z2luIHRvIHJvbGxcbiAgICAgIH0pO1xuICAgIH0pKCk7XG4gIH1cblxuICBwdWJsaWMgYWxsb3dfdW5wdWJsaXNoKFxuICAgIHsgcGFja2FnZU5hbWUsIHBhY2thZ2VWZXJzaW9uIH06IHBsdWdpblV0aWxzLkF1dGhQbHVnaW5QYWNrYWdlLFxuICAgIHVzZXI6IFJlbW90ZVVzZXIsXG4gICAgY2FsbGJhY2s6IENhbGxiYWNrXG4gICk6IHZvaWQge1xuICAgIGNvbnN0IHBrZyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICB7IG5hbWU6IHBhY2thZ2VOYW1lLCB2ZXJzaW9uOiBwYWNrYWdlVmVyc2lvbiB9LFxuICAgICAgZ2V0TWF0Y2hlZFBhY2thZ2VzU3BlYyhwYWNrYWdlTmFtZSwgdGhpcy5jb25maWcucGFja2FnZXMpXG4gICAgKTtcbiAgICBkZWJ1ZygnYWxsb3cgdW5wdWJsaXNoIGZvciAlbycsIHBhY2thZ2VOYW1lKTtcbiAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiB0aGlzLnBsdWdpbnMpIHtcbiAgICAgIGlmIChfLmlzTmlsKHBsdWdpbikgfHwgXy5pc0Z1bmN0aW9uKHBsdWdpbi5hbGxvd191bnB1Ymxpc2gpID09PSBmYWxzZSkge1xuICAgICAgICBkZWJ1ZygnYWxsb3cgdW5wdWJsaXNoIGZvciAlbyBwbHVnaW4gZG9lcyBub3QgaW1wbGVtZW50IGFsbG93X3VucHVibGlzaCcsIHBhY2thZ2VOYW1lKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHBsdWdpbi5hbGxvd191bnB1Ymxpc2ghKHVzZXIsIHBrZywgKGVyciwgb2s6IGJvb2xlYW4pOiB2b2lkID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcbiAgICAgICAgICAgICAgeyBwYWNrYWdlTmFtZSwgdXNlcjogdXNlcj8ubmFtZSB9LFxuICAgICAgICAgICAgICAnQHt1c2VyfSBmb3JiaWRkZW4gcHVibGlzaCBmb3IgQHtwYWNrYWdlTmFtZX0sIGl0IHdpbGwgZmFsbGJhY2sgb24gdW5wdWJsaXNoIHBlcm1pc3Npb25zJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChfLmlzTmlsKG9rKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgZGVidWcoJ3dlIGJ5cGFzcyB1bnB1Ymxpc2ggZm9yICVvLCBwdWJsaXNoIHdpbGwgaGFuZGxlIHRoZSBhY2Nlc3MnLCBwYWNrYWdlTmFtZSk7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFsbG93X3B1Ymxpc2goLi4uYXJndW1lbnRzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob2spIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oXG4gICAgICAgICAgICAgIHsgcGFja2FnZU5hbWUsIHVzZXI6IHVzZXI/Lm5hbWUgfSxcbiAgICAgICAgICAgICAgJ0B7dXNlcn0gYWxsb3dlZCB1bnB1Ymxpc2ggZm9yIEB7cGFja2FnZU5hbWV9J1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBvayk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWxsb3cgdXNlciB0byBwdWJsaXNoIGEgcGFja2FnZS5cbiAgICovXG4gIHB1YmxpYyBhbGxvd19wdWJsaXNoKFxuICAgIHsgcGFja2FnZU5hbWUsIHBhY2thZ2VWZXJzaW9uIH06IHBsdWdpblV0aWxzLkF1dGhQbHVnaW5QYWNrYWdlLFxuICAgIHVzZXI6IFJlbW90ZVVzZXIsXG4gICAgY2FsbGJhY2s6IENhbGxiYWNrXG4gICk6IHZvaWQge1xuICAgIGNvbnN0IHBsdWdpbnMgPSB0aGlzLnBsdWdpbnMuc2xpY2UoMCk7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgY29uc3QgcGtnID0gT2JqZWN0LmFzc2lnbihcbiAgICAgIHsgbmFtZTogcGFja2FnZU5hbWUsIHZlcnNpb246IHBhY2thZ2VWZXJzaW9uIH0sXG4gICAgICBnZXRNYXRjaGVkUGFja2FnZXNTcGVjKHBhY2thZ2VOYW1lLCB0aGlzLmNvbmZpZy5wYWNrYWdlcylcbiAgICApO1xuICAgIGRlYnVnKCdhbGxvdyBwdWJsaXNoIGZvciAlbyBpbml0IHwgcGx1Z2luczogJW8nLCBwYWNrYWdlTmFtZSwgcGx1Z2lucyk7XG4gICAgKGZ1bmN0aW9uIG5leHQoKTogdm9pZCB7XG4gICAgICBjb25zdCBwbHVnaW4gPSBwbHVnaW5zLnNoaWZ0KCk7XG5cbiAgICAgIGlmIChfLmlzTmlsKHBsdWdpbikgfHwgXy5pc0Z1bmN0aW9uKHBsdWdpbi5hbGxvd19wdWJsaXNoKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgZGVidWcoJ2FsbG93IHB1Ymxpc2ggZm9yICVvIHBsdWdpbiBkb2VzIG5vdCBpbXBsZW1lbnQgYWxsb3dfcHVibGlzaCcsIHBhY2thZ2VOYW1lKTtcbiAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgIH1cblxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgcGx1Z2luLmFsbG93X3B1Ymxpc2godXNlciwgcGtnLCAoZXJyOiBhbnksIG9rOiBib29sZWFuKTogdm9pZCA9PiB7XG4gICAgICAgIGlmIChfLmlzTmlsKGVycikgPT09IGZhbHNlICYmIF8uaXNFcnJvcihlcnIpKSB7XG4gICAgICAgICAgc2VsZi5sb2dnZXIuZXJyb3IoXG4gICAgICAgICAgICB7IHBhY2thZ2VOYW1lLCB1c2VyOiB1c2VyPy5uYW1lIH0sXG4gICAgICAgICAgICAnQHt1c2VyfSBpcyBmb3JiaWRkZW4gcHVibGlzaCBmb3IgQHtwYWNrYWdlTmFtZX0nXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvaykge1xuICAgICAgICAgIHNlbGYubG9nZ2VyLmluZm8oXG4gICAgICAgICAgICB7IHBhY2thZ2VOYW1lLCB1c2VyOiB1c2VyPy5uYW1lIH0sXG4gICAgICAgICAgICAnQHt1c2VyfSBpcyBhbGxvd2VkIHB1Ymxpc2ggZm9yIEB7cGFja2FnZU5hbWV9J1xuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIG9rKTtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1ZygnYWxsb3cgcHVibGlzaCBza2lwIHZhbGlkYXRpb24gZm9yICVvJywgcGFja2FnZU5hbWUpO1xuICAgICAgICBuZXh0KCk7IC8vIGNiKG51bGwsIGZhbHNlKSBjYXVzZXMgbmV4dCBwbHVnaW4gdG8gcm9sbFxuICAgICAgfSk7XG4gICAgfSkoKTtcbiAgfVxuXG4gIHB1YmxpYyBhcGlKV1RtaWRkbGV3YXJlKCkge1xuICAgIGNvbnN0IHBsdWdpbnMgPSB0aGlzLnBsdWdpbnMuc2xpY2UoMCk7XG4gICAgY29uc3QgaGVscGVycyA9IHsgY3JlYXRlQW5vbnltb3VzUmVtb3RlVXNlciwgY3JlYXRlUmVtb3RlVXNlciB9O1xuICAgIGZvciAoY29uc3QgcGx1Z2luIG9mIHBsdWdpbnMpIHtcbiAgICAgIGlmIChwbHVnaW4uYXBpSldUbWlkZGxld2FyZSkge1xuICAgICAgICByZXR1cm4gcGx1Z2luLmFwaUpXVG1pZGRsZXdhcmUoaGVscGVycyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChyZXE6ICRSZXF1ZXN0RXh0ZW5kLCByZXM6ICRSZXNwb25zZUV4dGVuZCwgX25leHQ6IE5leHRGdW5jdGlvbik6IHZvaWQgPT4ge1xuICAgICAgcmVxLnBhdXNlKCk7XG5cbiAgICAgIGNvbnN0IG5leHQgPSBmdW5jdGlvbiAoZXJyOiBhbnkgfCB2b2lkKTogdm9pZCB7XG4gICAgICAgIHJlcS5yZXN1bWUoKTtcbiAgICAgICAgLy8gdW5jb21tZW50IHRoaXMgdG8gcmVqZWN0IHVzZXJzIHdpdGggYmFkIGF1dGggaGVhZGVyc1xuICAgICAgICAvLyByZXR1cm4gX25leHQuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICAgICAgICAvLyBzd2FsbG93IGVycm9yLCB1c2VyIHJlbWFpbnMgdW5hdXRob3JpemVkXG4gICAgICAgIC8vIHNldCByZW1vdGVVc2VyRXJyb3IgdG8gaW5kaWNhdGUgdGhhdCB1c2VyIHdhcyBhdHRlbXB0aW5nIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXEucmVtb3RlX3VzZXIuZXJyb3IgPSBlcnIubWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX25leHQoKTtcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLl9pc1JlbW90ZVVzZXJWYWxpZChyZXEucmVtb3RlX3VzZXIpKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgIH1cblxuICAgICAgLy8gaW4gY2FzZSBhdXRoIGhlYWRlciBkb2VzIG5vdCBleGlzdCB3ZSByZXR1cm4gYW5vbnltb3VzIGZ1bmN0aW9uXG4gICAgICByZXEucmVtb3RlX3VzZXIgPSBjcmVhdGVBbm9ueW1vdXNSZW1vdGVVc2VyKCk7XG5cbiAgICAgIGNvbnN0IHsgYXV0aG9yaXphdGlvbiB9ID0gcmVxLmhlYWRlcnM7XG4gICAgICBpZiAoXy5pc05pbChhdXRob3JpemF0aW9uKSkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNBdXRoSGVhZGVyVmFsaWQoYXV0aG9yaXphdGlvbikpIHtcbiAgICAgICAgZGVidWcoJ2FwaSBtaWRkbGV3YXJlIGF1dGggaGVhdGhlciBpcyBub3QgdmFsaWQnKTtcbiAgICAgICAgcmV0dXJuIG5leHQoRXJyb3JDb2RlLmdldEJhZFJlcXVlc3QoQVBJX0VSUk9SLkJBRF9BVVRIX0hFQURFUikpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzZWN1cml0eTogU2VjdXJpdHkgPSBnZXRTZWN1cml0eSh0aGlzLmNvbmZpZyk7XG4gICAgICBjb25zdCB7IHNlY3JldCB9ID0gdGhpcy5jb25maWc7XG5cbiAgICAgIGlmIChpc0FFU0xlZ2FjeShzZWN1cml0eSkpIHtcbiAgICAgICAgZGVidWcoJ2FwaSBtaWRkbGV3YXJlIHVzaW5nIGxlZ2FjeSBhdXRoIHRva2VuJyk7XG4gICAgICAgIHRoaXMuX2hhbmRsZUFFU01pZGRsZXdhcmUocmVxLCBzZWN1cml0eSwgc2VjcmV0LCBhdXRob3JpemF0aW9uLCBuZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYnVnKCdhcGkgbWlkZGxld2FyZSB1c2luZyBKV1QgYXV0aCB0b2tlbicpO1xuICAgICAgICB0aGlzLl9oYW5kbGVKV1RBUElNaWRkbGV3YXJlKHJlcSwgc2VjdXJpdHksIHNlY3JldCwgYXV0aG9yaXphdGlvbiwgbmV4dCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgX2hhbmRsZUpXVEFQSU1pZGRsZXdhcmUoXG4gICAgcmVxOiAkUmVxdWVzdEV4dGVuZCxcbiAgICBzZWN1cml0eTogU2VjdXJpdHksXG4gICAgc2VjcmV0OiBzdHJpbmcsXG4gICAgYXV0aG9yaXphdGlvbjogc3RyaW5nLFxuICAgIG5leHQ6IEZ1bmN0aW9uXG4gICk6IHZvaWQge1xuICAgIGNvbnN0IHsgc2NoZW1lLCB0b2tlbiB9ID0gcGFyc2VBdXRoVG9rZW5IZWFkZXIoYXV0aG9yaXphdGlvbik7XG4gICAgaWYgKHNjaGVtZS50b1VwcGVyQ2FzZSgpID09PSBUT0tFTl9CQVNJQy50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAvLyB0aGlzIHNob3VsZCBoYXBwZW4gd2hlbiBjbGllbnQgdHJpZXMgdG8gbG9naW4gd2l0aCBhbiBleGlzdGluZyB1c2VyXG4gICAgICBjb25zdCBjcmVkZW50aWFscyA9IGNvbnZlcnRQYXlsb2FkVG9CYXNlNjQodG9rZW4pLnRvU3RyaW5nKCk7XG4gICAgICBjb25zdCB7IHVzZXIsIHBhc3N3b3JkIH0gPSBwYXJzZUJhc2ljUGF5bG9hZChjcmVkZW50aWFscykgYXMgQUVTUGF5bG9hZDtcbiAgICAgIHRoaXMuYXV0aGVudGljYXRlKHVzZXIsIHBhc3N3b3JkLCAoZXJyLCB1c2VyKTogdm9pZCA9PiB7XG4gICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgcmVxLnJlbW90ZV91c2VyID0gdXNlcjtcbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVxLnJlbW90ZV91c2VyID0gY3JlYXRlQW5vbnltb3VzUmVtb3RlVXNlcigpO1xuICAgICAgICAgIG5leHQoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGp3dCBoYW5kbGVyXG4gICAgICBjb25zdCBjcmVkZW50aWFsczogYW55ID0gZ2V0TWlkZGxld2FyZUNyZWRlbnRpYWxzKHNlY3VyaXR5LCBzZWNyZXQsIGF1dGhvcml6YXRpb24pO1xuICAgICAgaWYgKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIC8vIGlmIHRoZSBzaWduYXR1cmUgaXMgdmFsaWQgd2UgcmVseSBvbiBpdFxuICAgICAgICByZXEucmVtb3RlX3VzZXIgPSBjcmVkZW50aWFscztcbiAgICAgICAgbmV4dCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gd2l0aCBKV1QgdGhyb3cgNDAxXG4gICAgICAgIG5leHQoRXJyb3JDb2RlLmdldEZvcmJpZGRlbihBUElfRVJST1IuQkFEX1VTRVJOQU1FX1BBU1NXT1JEKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfaGFuZGxlQUVTTWlkZGxld2FyZShcbiAgICByZXE6ICRSZXF1ZXN0RXh0ZW5kLFxuICAgIHNlY3VyaXR5OiBTZWN1cml0eSxcbiAgICBzZWNyZXQ6IHN0cmluZyxcbiAgICBhdXRob3JpemF0aW9uOiBzdHJpbmcsXG4gICAgbmV4dDogRnVuY3Rpb25cbiAgKTogdm9pZCB7XG4gICAgY29uc3QgY3JlZGVudGlhbHM6IGFueSA9IGdldE1pZGRsZXdhcmVDcmVkZW50aWFscyhzZWN1cml0eSwgc2VjcmV0LCBhdXRob3JpemF0aW9uKTtcbiAgICBpZiAoY3JlZGVudGlhbHMpIHtcbiAgICAgIGNvbnN0IHsgdXNlciwgcGFzc3dvcmQgfSA9IGNyZWRlbnRpYWxzO1xuICAgICAgdGhpcy5hdXRoZW50aWNhdGUodXNlciwgcGFzc3dvcmQsIChlcnIsIHVzZXIpOiB2b2lkID0+IHtcbiAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICByZXEucmVtb3RlX3VzZXIgPSB1c2VyO1xuICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXEucmVtb3RlX3VzZXIgPSBjcmVhdGVBbm9ueW1vdXNSZW1vdGVVc2VyKCk7XG4gICAgICAgICAgbmV4dChlcnIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gd2UgZm9yY2UgbnBtIGNsaWVudCB0byBhc2sgYWdhaW4gd2l0aCBiYXNpYyBhdXRoZW50aWNhdGlvblxuICAgICAgcmV0dXJuIG5leHQoRXJyb3JDb2RlLmdldEJhZFJlcXVlc3QoQVBJX0VSUk9SLkJBRF9BVVRIX0hFQURFUikpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2lzUmVtb3RlVXNlclZhbGlkKHJlbW90ZV91c2VyOiBSZW1vdGVVc2VyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIF8uaXNVbmRlZmluZWQocmVtb3RlX3VzZXIpID09PSBmYWxzZSAmJiBfLmlzVW5kZWZpbmVkKHJlbW90ZV91c2VyLm5hbWUpID09PSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBKV1QgbWlkZGxld2FyZSBmb3IgV2ViVUlcbiAgICovXG4gIHB1YmxpYyB3ZWJVSUpXVG1pZGRsZXdhcmUoKTogRnVuY3Rpb24ge1xuICAgIHJldHVybiAocmVxOiAkUmVxdWVzdEV4dGVuZCwgcmVzOiAkUmVzcG9uc2VFeHRlbmQsIF9uZXh0OiBOZXh0RnVuY3Rpb24pOiB2b2lkID0+IHtcbiAgICAgIGlmICh0aGlzLl9pc1JlbW90ZVVzZXJWYWxpZChyZXEucmVtb3RlX3VzZXIpKSB7XG4gICAgICAgIHJldHVybiBfbmV4dCgpO1xuICAgICAgfVxuXG4gICAgICByZXEucGF1c2UoKTtcbiAgICAgIGNvbnN0IG5leHQgPSAoZXJyOiBhbnkgfCB2b2lkKTogdm9pZCA9PiB7XG4gICAgICAgIHJlcS5yZXN1bWUoKTtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIC8vIHJlcS5yZW1vdGVfdXNlci5lcnJvciA9IGVyci5tZXNzYWdlO1xuICAgICAgICAgIHJlcy5zdGF0dXMoZXJyLnN0YXR1c0NvZGUpLnNlbmQoZXJyLm1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9uZXh0KCk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCB7IGF1dGhvcml6YXRpb24gfSA9IHJlcS5oZWFkZXJzO1xuICAgICAgaWYgKF8uaXNOaWwoYXV0aG9yaXphdGlvbikpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzQXV0aEhlYWRlclZhbGlkKGF1dGhvcml6YXRpb24pKSB7XG4gICAgICAgIHJldHVybiBuZXh0KEVycm9yQ29kZS5nZXRCYWRSZXF1ZXN0KEFQSV9FUlJPUi5CQURfQVVUSF9IRUFERVIpKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdG9rZW4gPSAoYXV0aG9yaXphdGlvbiB8fCAnJykucmVwbGFjZShgJHtUT0tFTl9CRUFSRVJ9IGAsICcnKTtcbiAgICAgIGlmICghdG9rZW4pIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgfVxuXG4gICAgICBsZXQgY3JlZGVudGlhbHM7XG4gICAgICB0cnkge1xuICAgICAgICBjcmVkZW50aWFscyA9IHZlcmlmeUpXVFBheWxvYWQodG9rZW4sIHRoaXMuY29uZmlnLnNlY3JldCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gRklYTUU6IGludGVuZGVkIGJlaGF2aW91ciwgZG8gd2Ugd2FudCBpdD9cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2lzUmVtb3RlVXNlclZhbGlkKGNyZWRlbnRpYWxzKSkge1xuICAgICAgICBjb25zdCB7IG5hbWUsIGdyb3VwcyB9ID0gY3JlZGVudGlhbHM7XG4gICAgICAgIHJlcS5yZW1vdGVfdXNlciA9IGNyZWF0ZVJlbW90ZVVzZXIobmFtZSwgZ3JvdXBzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcS5yZW1vdGVfdXNlciA9IGNyZWF0ZUFub255bW91c1JlbW90ZVVzZXIoKTtcbiAgICAgIH1cbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIG5leHQoKTtcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGp3dEVuY3J5cHQodXNlcjogUmVtb3RlVXNlciwgc2lnbk9wdGlvbnM6IEpXVFNpZ25PcHRpb25zKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBjb25zdCB7IHJlYWxfZ3JvdXBzLCBuYW1lLCBncm91cHMgfSA9IHVzZXI7XG4gICAgY29uc3QgcmVhbEdyb3Vwc1ZhbGlkYXRlZCA9IF8uaXNOaWwocmVhbF9ncm91cHMpID8gW10gOiByZWFsX2dyb3VwcztcbiAgICBjb25zdCBncm91cGVkR3JvdXBzID0gXy5pc05pbChncm91cHMpXG4gICAgICA/IHJlYWxfZ3JvdXBzXG4gICAgICA6IEFycmF5LmZyb20obmV3IFNldChbLi4uZ3JvdXBzLmNvbmNhdChyZWFsR3JvdXBzVmFsaWRhdGVkKV0pKTtcbiAgICBjb25zdCBwYXlsb2FkOiBSZW1vdGVVc2VyID0ge1xuICAgICAgcmVhbF9ncm91cHM6IHJlYWxHcm91cHNWYWxpZGF0ZWQsXG4gICAgICBuYW1lLFxuICAgICAgZ3JvdXBzOiBncm91cGVkR3JvdXBzLFxuICAgIH07XG5cbiAgICBjb25zdCB0b2tlbjogc3RyaW5nID0gYXdhaXQgc2lnblBheWxvYWQocGF5bG9hZCwgdGhpcy5zZWNyZXQsIHNpZ25PcHRpb25zKTtcblxuICAgIHJldHVybiB0b2tlbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmNyeXB0IGEgc3RyaW5nLlxuICAgKi9cbiAgcHVibGljIGFlc0VuY3J5cHQoYnVmOiBCdWZmZXIpOiBCdWZmZXIge1xuICAgIHJldHVybiBhZXNFbmNyeXB0KGJ1ZiwgdGhp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