"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _JSONStream = _interopRequireDefault(require("JSONStream"));
var _debug = _interopRequireDefault(require("debug"));
var _lodash = _interopRequireDefault(require("lodash"));
var _request = _interopRequireDefault(require("request"));
var _stream = _interopRequireDefault(require("stream"));
var _url = _interopRequireDefault(require("url"));
var _zlib = _interopRequireDefault(require("zlib"));
var _streams = require("@verdaccio/streams");
var _utils = require("@verdaccio/utils");
var _constants = require("./constants");
var _logger = require("./logger");
var _utils2 = require("./utils");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const debug = (0, _debug.default)('verdaccio:proxy');
const encode = function (thing) {
  return encodeURIComponent(thing).replace(/^%40/, '@');
};
const jsonContentType = _constants.HEADERS.JSON;
const contentTypeAccept = `${jsonContentType};`;

/**
 * Just a helper (`config[key] || default` doesn't work because of zeroes)
 */
const setConfig = (config, key, def) => {
  return _lodash.default.isNil(config[key]) === false ? config[key] : def;
};

/**
 * Implements Storage interface
 * (same for storage.js, local-storage.js, up-storage.js)
 */
class ProxyStorage {
  // FIXME: upname is assigned to each instance
  // @ts-ignore

  // FIXME: proxy can be boolean or object, something smells here
  // @ts-ignore

  // @ts-ignore

  /**
   * Constructor
   * @param {*} config
   * @param {*} mainConfig
   */
  constructor(config, mainConfig) {
    var _mainConfig$user_agen;
    _defineProperty(this, "config", void 0);
    _defineProperty(this, "failed_requests", void 0);
    _defineProperty(this, "userAgent", void 0);
    _defineProperty(this, "ca", void 0);
    _defineProperty(this, "logger", void 0);
    _defineProperty(this, "server_id", void 0);
    _defineProperty(this, "url", void 0);
    _defineProperty(this, "maxage", void 0);
    _defineProperty(this, "timeout", void 0);
    _defineProperty(this, "max_fails", void 0);
    _defineProperty(this, "fail_timeout", void 0);
    _defineProperty(this, "agent_options", void 0);
    _defineProperty(this, "upname", void 0);
    _defineProperty(this, "proxy", void 0);
    _defineProperty(this, "last_request_time", void 0);
    _defineProperty(this, "strict_ssl", void 0);
    this.config = config;
    this.failed_requests = 0;
    // @ts-ignore
    this.userAgent = (_mainConfig$user_agen = mainConfig.user_agent) !== null && _mainConfig$user_agen !== void 0 ? _mainConfig$user_agen : 'hidden';
    this.ca = config.ca;
    this.logger = _logger.logger;
    this.server_id = mainConfig.server_id;
    this.url = _url.default.parse(this.config.url);
    this._setupProxy(this.url.hostname, config, mainConfig, this.url.protocol === 'https:');
    this.config.url = this.config.url.replace(/\/$/, '');
    if (this.config.timeout && Number(this.config.timeout) >= 1000) {
      this.logger.warn(['Too big timeout value: ' + this.config.timeout, 'We changed time format to nginx-like one', '(see http://nginx.org/en/docs/syntax.html)', 'so please update your config accordingly'].join('\n'));
    }

    // a bunch of different configurable timers
    this.maxage = (0, _utils2.parseInterval)(setConfig(this.config, 'maxage', '2m'));
    this.timeout = (0, _utils2.parseInterval)(setConfig(this.config, 'timeout', '30s'));
    this.max_fails = Number(setConfig(this.config, 'max_fails', 2));
    this.fail_timeout = (0, _utils2.parseInterval)(setConfig(this.config, 'fail_timeout', '5m'));
    this.strict_ssl = Boolean(setConfig(this.config, 'strict_ssl', true));
    this.agent_options = setConfig(this.config, 'agent_options', {
      keepAlive: true,
      maxSockets: 40,
      maxFreeSockets: 10
    });
  }

  /**
   * Fetch an asset.
   * @param {*} options
   * @param {*} cb
   * @return {Request}
   */
  request(options, cb) {
    let json;
    if (this._statusCheck() === false) {
      const streamRead = new _stream.default.Readable();
      process.nextTick(function () {
        if (cb) {
          cb(_utils2.ErrorCode.getInternalError(_constants.API_ERROR.UPLINK_OFFLINE));
        }
        streamRead.emit('error', _utils2.ErrorCode.getInternalError(_constants.API_ERROR.UPLINK_OFFLINE));
      });
      streamRead._read = function () {};
      // preventing 'Uncaught, unspecified "error" event'
      streamRead.on('error', function () {});
      return streamRead;
    }
    const self = this;
    const headers = this._setHeaders(options);
    this._addProxyHeaders(options.req, headers);
    this._overrideWithUpLinkConfigHeaders(headers);
    const method = options.method || 'GET';
    const uri = options.uri_full || this.config.url + options.uri;
    self.logger.info({
      method: method,
      uri: uri
    }, "making request: '@{method} @{uri}'");
    if ((0, _utils2.isObject)(options.json)) {
      json = JSON.stringify(options.json);
      headers['Content-Type'] = headers['Content-Type'] || _constants.HEADERS.JSON;
    }
    const requestCallback = cb ? function (err, res, body) {
      let error;
      const responseLength = err ? 0 : body.length;
      processBody();
      logActivity();
      cb(err, res, body);

      /**
       * Perform a decode.
       */
      function processBody() {
        if (err) {
          error = err.message;
          return;
        }
        if (options.json && res.statusCode < 300) {
          try {
            body = JSON.parse(body.toString(_constants.CHARACTER_ENCODING.UTF8));
          } catch (_err) {
            body = {};
            err = _err;
            error = err.message;
          }
        }
        if (!err && (0, _utils2.isObject)(body)) {
          if (_lodash.default.isString(body.error)) {
            error = body.error;
          }
        }
      }
      /**
       * Perform a log.
       */
      function logActivity() {
        let message = "@{!status}, req: '@{request.method} @{request.url}'";
        message += error ? ', error: @{!error}' : ', bytes: @{bytes.in}/@{bytes.out}';
        self.logger.http({
          err: err || undefined,
          // if error is null/false change this to undefined so it wont log
          request: {
            method: method,
            url: uri
          },
          status: res != null ? res.statusCode : 'ERR',
          error: error,
          bytes: {
            in: json ? json.length : 0,
            out: responseLength || 0
          }
        }, message);
      }
    } : undefined;
    let requestOptions = {
      url: uri,
      method: method,
      headers: headers,
      body: json,
      proxy: this.proxy,
      encoding: null,
      gzip: true,
      timeout: this.timeout,
      strictSSL: this.strict_ssl,
      agentOptions: this.agent_options
    };
    if (this.ca) {
      requestOptions = Object.assign({}, requestOptions, {
        ca: this.ca
      });
    }
    const req = (0, _request.default)(requestOptions, requestCallback);
    let statusCalled = false;
    req.on('response', function (res) {
      // FIXME: _verdaccio_aborted seems not used
      // @ts-ignore
      if (!req._verdaccio_aborted && !statusCalled) {
        statusCalled = true;
        self._statusCheck(true);
      }
      if (_lodash.default.isNil(requestCallback) === false) {
        (function do_log() {
          const message = "@{!status}, req: '@{request.method} @{request.url}' (streaming)";
          self.logger.http({
            request: {
              method: method,
              url: uri
            },
            status: _lodash.default.isNull(res) === false ? res.statusCode : 'ERR'
          }, message);
        })();
      }
    });
    req.on('error', function (_err) {
      // FIXME: _verdaccio_aborted seems not used
      // @ts-ignore
      if (!req._verdaccio_aborted && !statusCalled) {
        statusCalled = true;
        self._statusCheck(false);
      }
    });
    // @ts-ignore
    return req;
  }

  /**
   * Set default headers.
   * @param {Object} options
   * @return {Object}
   * @private
   */
  _setHeaders(options) {
    var _options$req;
    const headers = options.headers || {};
    const accept = _constants.HEADERS.ACCEPT;
    const acceptEncoding = _constants.HEADERS.ACCEPT_ENCODING;
    const userAgent = _constants.HEADERS.USER_AGENT;
    headers[accept] = headers[accept] || contentTypeAccept;
    headers[acceptEncoding] = headers[acceptEncoding] || 'gzip';
    // registry.npmjs.org will only return search result if user-agent include string 'npm'
    headers[userAgent] = this.userAgent ? `npm (${this.userAgent})` : (_options$req = options.req) === null || _options$req === void 0 ? void 0 : _options$req.get('user-agent');
    return this._setAuth(headers);
  }

  /**
   * Validate configuration auth and assign Header authorization
   * @param {Object} headers
   * @return {Object}
   * @private
   */
  _setAuth(headers) {
    const {
      auth
    } = this.config;
    if (_lodash.default.isNil(auth) || headers[_constants.HEADERS.AUTHORIZATION]) {
      return headers;
    }
    if (_lodash.default.isObject(auth) === false && _lodash.default.isObject(auth.token) === false) {
      this._throwErrorAuth('Auth invalid');
    }

    // get NPM_TOKEN http://blog.npmjs.org/post/118393368555/deploying-with-npm-private-modules
    // or get other variable export in env
    // https://github.com/verdaccio/verdaccio/releases/tag/v2.5.0
    let token;
    const tokenConf = auth;
    if (_lodash.default.isNil(tokenConf.token) === false && _lodash.default.isString(tokenConf.token)) {
      token = tokenConf.token;
    } else if (_lodash.default.isNil(tokenConf.token_env) === false) {
      if (_lodash.default.isString(tokenConf.token_env)) {
        token = process.env[tokenConf.token_env];
      } else if (_lodash.default.isBoolean(tokenConf.token_env) && tokenConf.token_env) {
        token = process.env.NPM_TOKEN;
      } else {
        this.logger.error(_constants.ERROR_CODE.token_required);
        this._throwErrorAuth(_constants.ERROR_CODE.token_required);
      }
    } else {
      token = process.env.NPM_TOKEN;
    }
    if (_lodash.default.isNil(token)) {
      this._throwErrorAuth(_constants.ERROR_CODE.token_required);
    }

    // define type Auth allow basic and bearer
    const type = tokenConf.type || _constants.TOKEN_BASIC;
    this._setHeaderAuthorization(headers, type, token);
    return headers;
  }

  /**
   * @param {string} message
   * @throws {Error}
   * @private
   */
  _throwErrorAuth(message) {
    this.logger.error(message);
    throw new Error(message);
  }

  /**
   * Assign Header authorization with type authentication
   * @param {Object} headers
   * @param {string} type
   * @param {string} token
   * @private
   */
  _setHeaderAuthorization(headers, type, token) {
    const _type = type.toLowerCase();
    if (_type !== _constants.TOKEN_BEARER.toLowerCase() && _type !== _constants.TOKEN_BASIC.toLowerCase()) {
      this._throwErrorAuth(`Auth type '${_type}' not allowed`);
    }
    type = _lodash.default.upperFirst(type);
    headers[_constants.HEADERS.AUTHORIZATION] = (0, _utils.buildToken)(type, token);
  }

  /**
   * It will add or override specified headers from config file.
   *
   * Eg:
   *
   * uplinks:
   npmjs:
   url: https://registry.npmjs.org/
   headers:
   Accept: "application/vnd.npm.install-v2+json; q=1.0"
   verdaccio-staging:
   url: https://mycompany.com/npm
   headers:
   Accept: "application/json"
   authorization: "Basic YourBase64EncodedCredentials=="
    * @param {Object} headers
   * @private
   */
  _overrideWithUpLinkConfigHeaders(headers) {
    if (!this.config.headers) {
      return headers;
    }

    // add/override headers specified in the config
    /* eslint guard-for-in: 0 */
    for (const key in this.config.headers) {
      headers[key] = this.config.headers[key];
    }
  }

  /**
   * Determine whether can fetch from the provided URL
   * @param {*} url
   * @return {Boolean}
   */
  isUplinkValid(url) {
    const urlParsed = _url.default.parse(url);
    const isHTTPS = urlDomainParsed => urlDomainParsed.protocol === 'https:' && (urlParsed.port === null || urlParsed.port === '443');
    const getHost = urlDomainParsed => isHTTPS(urlDomainParsed) ? urlDomainParsed.hostname : urlDomainParsed.host;
    const isMatchProtocol = urlParsed.protocol === this.url.protocol;
    const isMatchHost = getHost(urlParsed) === getHost(this.url);
    // @ts-ignore
    const isMatchPath = urlParsed.path.indexOf(this.url.path) === 0;
    return isMatchProtocol && isMatchHost && isMatchPath;
  }

  /**
   * Get a remote package metadata
   * @param {*} name package name
   * @param {*} options request options, eg: eTag.
   * @param {*} callback
   */
  getRemoteMetadata(name, options, callback) {
    const headers = {};
    if (_lodash.default.isNil(options.etag) === false) {
      headers['If-None-Match'] = options.etag;
      headers[_constants.HEADERS.ACCEPT] = contentTypeAccept;
    }
    this.request({
      uri: `/${encode(name)}`,
      json: true,
      headers: headers,
      req: options.req
    }, (err, res, body) => {
      if (err) {
        return callback(err);
      }
      if (res.statusCode === _constants.HTTP_STATUS.NOT_FOUND) {
        return callback(_utils2.ErrorCode.getNotFound(_constants.API_ERROR.NOT_PACKAGE_UPLINK));
      }
      if (!(res.statusCode >= _constants.HTTP_STATUS.OK && res.statusCode < _constants.HTTP_STATUS.MULTIPLE_CHOICES)) {
        const error = _utils2.ErrorCode.getInternalError(`${_constants.API_ERROR.BAD_STATUS_CODE}: ${res.statusCode}`);
        error.remoteStatus = res.statusCode;
        return callback(error);
      }
      callback(null, body, res.headers.etag);
    });
  }

  /**
   * Fetch a tarball from the uplink.
   * @param {String} url
   * @return {Stream}
   */
  fetchTarball(url) {
    const stream = new _streams.ReadTarball({});
    let current_length = 0;
    let expected_length;
    stream.abort = () => {};
    const readStream = this.request({
      uri_full: url,
      encoding: null,
      headers: {
        Accept: contentTypeAccept
      }
    });
    readStream.on('response', function (res) {
      if (res.statusCode === _constants.HTTP_STATUS.NOT_FOUND) {
        return stream.emit('error', _utils2.ErrorCode.getNotFound(_constants.API_ERROR.NOT_FILE_UPLINK));
      }
      if (!(res.statusCode >= _constants.HTTP_STATUS.OK && res.statusCode < _constants.HTTP_STATUS.MULTIPLE_CHOICES)) {
        return stream.emit('error', _utils2.ErrorCode.getInternalError(`bad uplink status code: ${res.statusCode}`));
      }
      if (res.headers[_constants.HEADER_TYPE.CONTENT_LENGTH]) {
        expected_length = res.headers[_constants.HEADER_TYPE.CONTENT_LENGTH];
        stream.emit(_constants.HEADER_TYPE.CONTENT_LENGTH, res.headers[_constants.HEADER_TYPE.CONTENT_LENGTH]);
      }
      readStream.pipe(stream);
    });
    readStream.on('error', function (err) {
      stream.emit('error', err);
    });
    readStream.on('data', function (data) {
      current_length += data.length;
    });
    readStream.on('end', function (data) {
      if (data) {
        current_length += data.length;
      }
      if (expected_length && current_length != expected_length) {
        stream.emit('error', _utils2.ErrorCode.getInternalError(_constants.API_ERROR.CONTENT_MISMATCH));
      }
    });
    return stream;
  }

  /**
   * Perform a stream search.
   * @param {*} options request options
   * @return {Stream}
   */
  search(options) {
    const transformStream = new _stream.default.PassThrough({
      objectMode: true
    });
    const requestStream = this.request({
      uri: options.req.url,
      req: options.req,
      headers: {
        // query for search
        referer: options.req.get('referer')
      }
    });
    const parsePackage = pkg => {
      if ((0, _utils2.isObjectOrArray)(pkg)) {
        transformStream.emit('data', pkg);
      }
    };
    requestStream.on('response', res => {
      if (!String(res.statusCode).match(/^2\d\d$/)) {
        return transformStream.emit('error', _utils2.ErrorCode.getInternalError(`bad status code ${res.statusCode} from uplink`));
      }

      // See https://github.com/request/request#requestoptions-callback
      // Request library will not decode gzip stream.
      let jsonStream;
      if (res.headers[_constants.HEADER_TYPE.CONTENT_ENCODING] === _constants.HEADERS.GZIP) {
        jsonStream = res.pipe(_zlib.default.createUnzip());
      } else {
        jsonStream = res;
      }
      jsonStream.pipe(_JSONStream.default.parse('*')).on('data', parsePackage);
      jsonStream.on('end', () => {
        transformStream.emit('end');
      });
    });
    requestStream.on('error', err => {
      transformStream.emit('error', err);
    });
    transformStream.abort = () => {
      // FIXME: this is clearly a potential issue
      // there is no abort method on Stream.Readable
      // @ts-ignore
      requestStream.abort();
      transformStream.emit('end');
    };
    return transformStream;
  }

  /**
   * Add proxy headers.
   * FIXME: object mutations, it should return an new object
   * @param {*} req the http request
   * @param {*} headers the request headers
   */
  _addProxyHeaders(req, headers) {
    if (req) {
      // Only submit X-Forwarded-For field if we don't have a proxy selected
      // in the config file.
      //
      // Otherwise misconfigured proxy could return 407:
      // https://github.com/rlidwka/sinopia/issues/254
      //
      // FIXME: proxy logic is odd, something is wrong here.
      // @ts-ignore
      if (!this.proxy) {
        headers['x-forwarded-for'] = (req.get('x-forwarded-for') ? req.get('x-forwarded-for') + ', ' : '') + req.connection.remoteAddress;
      }
    }

    // always attach Via header to avoid loops, even if we're not proxying
    headers['via'] = req && req.get('via') ? req.get('via') + ', ' : '';
    headers['via'] += '1.1 ' + this.server_id + ' (Verdaccio)';
  }

  /**
   * Check whether the remote host is available.
   * @param {*} alive
   * @return {Boolean}
   */
  _statusCheck(alive) {
    if (arguments.length === 0) {
      return this._ifRequestFailure() === false;
    }
    if (alive) {
      if (this.failed_requests >= this.max_fails) {
        this.logger.warn({
          host: this.url.host
        }, 'host @{host} is back online');
      }
      this.failed_requests = 0;
    } else {
      this.failed_requests++;
      if (this.failed_requests === this.max_fails) {
        this.logger.warn({
          host: this.url.host
        }, 'host @{host} is now offline');
      }
    }
    this.last_request_time = Date.now();
  }

  /**
   * If the request failure.
   * @return {boolean}
   * @private
   */
  _ifRequestFailure() {
    return this.failed_requests >= this.max_fails && Math.abs(Date.now() - this.last_request_time) < this.fail_timeout;
  }

  /**
   * Set up a proxy.
   * @param {*} hostname
   * @param {*} config
   * @param {*} mainconfig
   * @param {*} isHTTPS
   */
  _setupProxy(hostname, config, mainconfig, isHTTPS) {
    let noProxyList;
    const proxy_key = isHTTPS ? 'https_proxy' : 'http_proxy';

    // get http_proxy and no_proxy configs
    if (proxy_key in config) {
      this.proxy = config[proxy_key];
    } else if (proxy_key in mainconfig) {
      this.proxy = mainconfig[proxy_key];
    }
    if ('no_proxy' in config) {
      noProxyList = config.no_proxy;
    } else if ('no_proxy' in mainconfig) {
      noProxyList = mainconfig.no_proxy;
    }

    // use wget-like algorithm to determine if proxy shouldn't be used
    if (hostname[0] !== '.') {
      hostname = '.' + hostname;
    }
    if (_lodash.default.isString(noProxyList) && noProxyList.length) {
      noProxyList = noProxyList.split(',');
    }
    if (_lodash.default.isArray(noProxyList)) {
      for (let i = 0; i < noProxyList.length; i++) {
        let noProxyItem = noProxyList[i];
        if (noProxyItem[0] !== '.') {
          noProxyItem = '.' + noProxyItem;
        }
        if (hostname.lastIndexOf(noProxyItem) === hostname.length - noProxyItem.length) {
          if (this.proxy) {
            debug('not using proxy for %o, excluded by %o rule', this.url.href, noProxyItem);
            // @ts-ignore
            this.proxy = false;
          }
          break;
        }
      }
    }

    // if it's non-string (i.e. "false"), don't use it
    if (_lodash.default.isString(this.proxy) === false) {
      // @ts-ignore
      delete this.proxy;
    } else {
      debug('using proxy %o for %o', this.url.href, this.proxy);
    }
  }
}
var _default = ProxyStorage;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfSlNPTlN0cmVhbSIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiX2RlYnVnIiwiX2xvZGFzaCIsIl9yZXF1ZXN0IiwiX3N0cmVhbSIsIl91cmwiLCJfemxpYiIsIl9zdHJlYW1zIiwiX3V0aWxzIiwiX2NvbnN0YW50cyIsIl9sb2dnZXIiLCJfdXRpbHMyIiwib2JqIiwiX19lc01vZHVsZSIsImRlZmF1bHQiLCJfZGVmaW5lUHJvcGVydHkiLCJrZXkiLCJ2YWx1ZSIsIl90b1Byb3BlcnR5S2V5IiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJhcmciLCJfdG9QcmltaXRpdmUiLCJTdHJpbmciLCJpbnB1dCIsImhpbnQiLCJwcmltIiwiU3ltYm9sIiwidG9QcmltaXRpdmUiLCJ1bmRlZmluZWQiLCJyZXMiLCJjYWxsIiwiVHlwZUVycm9yIiwiTnVtYmVyIiwiZGVidWciLCJidWlsZERlYnVnIiwiZW5jb2RlIiwidGhpbmciLCJlbmNvZGVVUklDb21wb25lbnQiLCJyZXBsYWNlIiwianNvbkNvbnRlbnRUeXBlIiwiSEVBREVSUyIsIkpTT04iLCJjb250ZW50VHlwZUFjY2VwdCIsInNldENvbmZpZyIsImNvbmZpZyIsImRlZiIsIl8iLCJpc05pbCIsIlByb3h5U3RvcmFnZSIsImNvbnN0cnVjdG9yIiwibWFpbkNvbmZpZyIsIl9tYWluQ29uZmlnJHVzZXJfYWdlbiIsImZhaWxlZF9yZXF1ZXN0cyIsInVzZXJBZ2VudCIsInVzZXJfYWdlbnQiLCJjYSIsImxvZ2dlciIsInNlcnZlcl9pZCIsInVybCIsIlVSTCIsInBhcnNlIiwiX3NldHVwUHJveHkiLCJob3N0bmFtZSIsInByb3RvY29sIiwidGltZW91dCIsIndhcm4iLCJqb2luIiwibWF4YWdlIiwicGFyc2VJbnRlcnZhbCIsIm1heF9mYWlscyIsImZhaWxfdGltZW91dCIsInN0cmljdF9zc2wiLCJCb29sZWFuIiwiYWdlbnRfb3B0aW9ucyIsImtlZXBBbGl2ZSIsIm1heFNvY2tldHMiLCJtYXhGcmVlU29ja2V0cyIsInJlcXVlc3QiLCJvcHRpb25zIiwiY2IiLCJqc29uIiwiX3N0YXR1c0NoZWNrIiwic3RyZWFtUmVhZCIsIlN0cmVhbSIsIlJlYWRhYmxlIiwicHJvY2VzcyIsIm5leHRUaWNrIiwiRXJyb3JDb2RlIiwiZ2V0SW50ZXJuYWxFcnJvciIsIkFQSV9FUlJPUiIsIlVQTElOS19PRkZMSU5FIiwiZW1pdCIsIl9yZWFkIiwib24iLCJzZWxmIiwiaGVhZGVycyIsIl9zZXRIZWFkZXJzIiwiX2FkZFByb3h5SGVhZGVycyIsInJlcSIsIl9vdmVycmlkZVdpdGhVcExpbmtDb25maWdIZWFkZXJzIiwibWV0aG9kIiwidXJpIiwidXJpX2Z1bGwiLCJpbmZvIiwiaXNPYmplY3QiLCJzdHJpbmdpZnkiLCJyZXF1ZXN0Q2FsbGJhY2siLCJlcnIiLCJib2R5IiwiZXJyb3IiLCJyZXNwb25zZUxlbmd0aCIsImxlbmd0aCIsInByb2Nlc3NCb2R5IiwibG9nQWN0aXZpdHkiLCJtZXNzYWdlIiwic3RhdHVzQ29kZSIsInRvU3RyaW5nIiwiQ0hBUkFDVEVSX0VOQ09ESU5HIiwiVVRGOCIsIl9lcnIiLCJpc1N0cmluZyIsImh0dHAiLCJzdGF0dXMiLCJieXRlcyIsImluIiwib3V0IiwicmVxdWVzdE9wdGlvbnMiLCJwcm94eSIsImVuY29kaW5nIiwiZ3ppcCIsInN0cmljdFNTTCIsImFnZW50T3B0aW9ucyIsImFzc2lnbiIsInN0YXR1c0NhbGxlZCIsIl92ZXJkYWNjaW9fYWJvcnRlZCIsImRvX2xvZyIsImlzTnVsbCIsIl9vcHRpb25zJHJlcSIsImFjY2VwdCIsIkFDQ0VQVCIsImFjY2VwdEVuY29kaW5nIiwiQUNDRVBUX0VOQ09ESU5HIiwiVVNFUl9BR0VOVCIsImdldCIsIl9zZXRBdXRoIiwiYXV0aCIsIkFVVEhPUklaQVRJT04iLCJ0b2tlbiIsIl90aHJvd0Vycm9yQXV0aCIsInRva2VuQ29uZiIsInRva2VuX2VudiIsImVudiIsImlzQm9vbGVhbiIsIk5QTV9UT0tFTiIsIkVSUk9SX0NPREUiLCJ0b2tlbl9yZXF1aXJlZCIsInR5cGUiLCJUT0tFTl9CQVNJQyIsIl9zZXRIZWFkZXJBdXRob3JpemF0aW9uIiwiRXJyb3IiLCJfdHlwZSIsInRvTG93ZXJDYXNlIiwiVE9LRU5fQkVBUkVSIiwidXBwZXJGaXJzdCIsImJ1aWxkVG9rZW4iLCJpc1VwbGlua1ZhbGlkIiwidXJsUGFyc2VkIiwiaXNIVFRQUyIsInVybERvbWFpblBhcnNlZCIsInBvcnQiLCJnZXRIb3N0IiwiaG9zdCIsImlzTWF0Y2hQcm90b2NvbCIsImlzTWF0Y2hIb3N0IiwiaXNNYXRjaFBhdGgiLCJwYXRoIiwiaW5kZXhPZiIsImdldFJlbW90ZU1ldGFkYXRhIiwibmFtZSIsImNhbGxiYWNrIiwiZXRhZyIsIkhUVFBfU1RBVFVTIiwiTk9UX0ZPVU5EIiwiZ2V0Tm90Rm91bmQiLCJOT1RfUEFDS0FHRV9VUExJTksiLCJPSyIsIk1VTFRJUExFX0NIT0lDRVMiLCJCQURfU1RBVFVTX0NPREUiLCJyZW1vdGVTdGF0dXMiLCJmZXRjaFRhcmJhbGwiLCJzdHJlYW0iLCJSZWFkVGFyYmFsbCIsImN1cnJlbnRfbGVuZ3RoIiwiZXhwZWN0ZWRfbGVuZ3RoIiwiYWJvcnQiLCJyZWFkU3RyZWFtIiwiQWNjZXB0IiwiTk9UX0ZJTEVfVVBMSU5LIiwiSEVBREVSX1RZUEUiLCJDT05URU5UX0xFTkdUSCIsInBpcGUiLCJkYXRhIiwiQ09OVEVOVF9NSVNNQVRDSCIsInNlYXJjaCIsInRyYW5zZm9ybVN0cmVhbSIsIlBhc3NUaHJvdWdoIiwib2JqZWN0TW9kZSIsInJlcXVlc3RTdHJlYW0iLCJyZWZlcmVyIiwicGFyc2VQYWNrYWdlIiwicGtnIiwiaXNPYmplY3RPckFycmF5IiwibWF0Y2giLCJqc29uU3RyZWFtIiwiQ09OVEVOVF9FTkNPRElORyIsIkdaSVAiLCJ6bGliIiwiY3JlYXRlVW56aXAiLCJKU09OU3RyZWFtIiwiY29ubmVjdGlvbiIsInJlbW90ZUFkZHJlc3MiLCJhbGl2ZSIsImFyZ3VtZW50cyIsIl9pZlJlcXVlc3RGYWlsdXJlIiwibGFzdF9yZXF1ZXN0X3RpbWUiLCJEYXRlIiwibm93IiwiTWF0aCIsImFicyIsIm1haW5jb25maWciLCJub1Byb3h5TGlzdCIsInByb3h5X2tleSIsIm5vX3Byb3h5Iiwic3BsaXQiLCJpc0FycmF5IiwiaSIsIm5vUHJveHlJdGVtIiwibGFzdEluZGV4T2YiLCJocmVmIiwiX2RlZmF1bHQiLCJleHBvcnRzIl0sInNvdXJjZXMiOlsiLi4vLi4vc3JjL2xpYi91cC1zdG9yYWdlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBKU09OU3RyZWFtIGZyb20gJ0pTT05TdHJlYW0nO1xuaW1wb3J0IGJ1aWxkRGVidWcgZnJvbSAnZGVidWcnO1xuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCByZXF1ZXN0IGZyb20gJ3JlcXVlc3QnO1xuaW1wb3J0IFN0cmVhbSBmcm9tICdzdHJlYW0nO1xuaW1wb3J0IFVSTCwgeyBVcmxXaXRoU3RyaW5nUXVlcnkgfSBmcm9tICd1cmwnO1xuaW1wb3J0IHpsaWIgZnJvbSAnemxpYic7XG5cbmltcG9ydCB7IFJlYWRUYXJiYWxsIH0gZnJvbSAnQHZlcmRhY2Npby9zdHJlYW1zJztcbmltcG9ydCB7IENhbGxiYWNrLCBDb25maWcsIEhlYWRlcnMsIExvZ2dlciwgUGFja2FnZSwgVXBMaW5rQ29uZiB9IGZyb20gJ0B2ZXJkYWNjaW8vdHlwZXMnO1xuaW1wb3J0IHsgYnVpbGRUb2tlbiB9IGZyb20gJ0B2ZXJkYWNjaW8vdXRpbHMnO1xuXG5pbXBvcnQge1xuICBBUElfRVJST1IsXG4gIENIQVJBQ1RFUl9FTkNPRElORyxcbiAgRVJST1JfQ09ERSxcbiAgSEVBREVSUyxcbiAgSEVBREVSX1RZUEUsXG4gIEhUVFBfU1RBVFVTLFxuICBUT0tFTl9CQVNJQyxcbiAgVE9LRU5fQkVBUkVSLFxufSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuL2xvZ2dlcic7XG5pbXBvcnQgeyBFcnJvckNvZGUsIGlzT2JqZWN0LCBpc09iamVjdE9yQXJyYXksIHBhcnNlSW50ZXJ2YWwgfSBmcm9tICcuL3V0aWxzJztcblxuY29uc3QgZGVidWcgPSBidWlsZERlYnVnKCd2ZXJkYWNjaW86cHJveHknKTtcblxuY29uc3QgZW5jb2RlID0gZnVuY3Rpb24gKHRoaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh0aGluZykucmVwbGFjZSgvXiU0MC8sICdAJyk7XG59O1xuXG5jb25zdCBqc29uQ29udGVudFR5cGUgPSBIRUFERVJTLkpTT047XG5jb25zdCBjb250ZW50VHlwZUFjY2VwdCA9IGAke2pzb25Db250ZW50VHlwZX07YDtcblxuLyoqXG4gKiBKdXN0IGEgaGVscGVyIChgY29uZmlnW2tleV0gfHwgZGVmYXVsdGAgZG9lc24ndCB3b3JrIGJlY2F1c2Ugb2YgemVyb2VzKVxuICovXG5jb25zdCBzZXRDb25maWcgPSAoY29uZmlnLCBrZXksIGRlZik6IHN0cmluZyA9PiB7XG4gIHJldHVybiBfLmlzTmlsKGNvbmZpZ1trZXldKSA9PT0gZmFsc2UgPyBjb25maWdba2V5XSA6IGRlZjtcbn07XG5cbi8qKlxuICogSW1wbGVtZW50cyBTdG9yYWdlIGludGVyZmFjZVxuICogKHNhbWUgZm9yIHN0b3JhZ2UuanMsIGxvY2FsLXN0b3JhZ2UuanMsIHVwLXN0b3JhZ2UuanMpXG4gKi9cbmNsYXNzIFByb3h5U3RvcmFnZSB7XG4gIHB1YmxpYyBjb25maWc6IFVwTGlua0NvbmY7XG4gIHB1YmxpYyBmYWlsZWRfcmVxdWVzdHM6IG51bWJlcjtcbiAgcHVibGljIHVzZXJBZ2VudDogc3RyaW5nO1xuICBwdWJsaWMgY2E6IHN0cmluZyB8IHZvaWQ7XG4gIHB1YmxpYyBsb2dnZXI6IExvZ2dlcjtcbiAgcHVibGljIHNlcnZlcl9pZDogc3RyaW5nO1xuICBwdWJsaWMgdXJsOiBhbnk7XG4gIHB1YmxpYyBtYXhhZ2U6IG51bWJlcjtcbiAgcHVibGljIHRpbWVvdXQ6IG51bWJlcjtcbiAgcHVibGljIG1heF9mYWlsczogbnVtYmVyO1xuICBwdWJsaWMgZmFpbF90aW1lb3V0OiBudW1iZXI7XG4gIHB1YmxpYyBhZ2VudF9vcHRpb25zOiBhbnk7XG4gIC8vIEZJWE1FOiB1cG5hbWUgaXMgYXNzaWduZWQgdG8gZWFjaCBpbnN0YW5jZVxuICAvLyBAdHMtaWdub3JlXG4gIHB1YmxpYyB1cG5hbWU6IHN0cmluZztcbiAgLy8gRklYTUU6IHByb3h5IGNhbiBiZSBib29sZWFuIG9yIG9iamVjdCwgc29tZXRoaW5nIHNtZWxscyBoZXJlXG4gIC8vIEB0cy1pZ25vcmVcbiAgcHVibGljIHByb3h5OiBzdHJpbmcgfCB2b2lkO1xuICAvLyBAdHMtaWdub3JlXG4gIHB1YmxpYyBsYXN0X3JlcXVlc3RfdGltZTogbnVtYmVyIHwgbnVsbDtcbiAgcHVibGljIHN0cmljdF9zc2w6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7Kn0gY29uZmlnXG4gICAqIEBwYXJhbSB7Kn0gbWFpbkNvbmZpZ1xuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKGNvbmZpZzogVXBMaW5rQ29uZiwgbWFpbkNvbmZpZzogQ29uZmlnKSB7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5mYWlsZWRfcmVxdWVzdHMgPSAwO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLnVzZXJBZ2VudCA9IG1haW5Db25maWcudXNlcl9hZ2VudCA/PyAnaGlkZGVuJztcbiAgICB0aGlzLmNhID0gY29uZmlnLmNhO1xuICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICAgIHRoaXMuc2VydmVyX2lkID0gbWFpbkNvbmZpZy5zZXJ2ZXJfaWQ7XG5cbiAgICB0aGlzLnVybCA9IFVSTC5wYXJzZSh0aGlzLmNvbmZpZy51cmwpO1xuXG4gICAgdGhpcy5fc2V0dXBQcm94eSh0aGlzLnVybC5ob3N0bmFtZSwgY29uZmlnLCBtYWluQ29uZmlnLCB0aGlzLnVybC5wcm90b2NvbCA9PT0gJ2h0dHBzOicpO1xuXG4gICAgdGhpcy5jb25maWcudXJsID0gdGhpcy5jb25maWcudXJsLnJlcGxhY2UoL1xcLyQvLCAnJyk7XG5cbiAgICBpZiAodGhpcy5jb25maWcudGltZW91dCAmJiBOdW1iZXIodGhpcy5jb25maWcudGltZW91dCkgPj0gMTAwMCkge1xuICAgICAgdGhpcy5sb2dnZXIud2FybihcbiAgICAgICAgW1xuICAgICAgICAgICdUb28gYmlnIHRpbWVvdXQgdmFsdWU6ICcgKyB0aGlzLmNvbmZpZy50aW1lb3V0LFxuICAgICAgICAgICdXZSBjaGFuZ2VkIHRpbWUgZm9ybWF0IHRvIG5naW54LWxpa2Ugb25lJyxcbiAgICAgICAgICAnKHNlZSBodHRwOi8vbmdpbngub3JnL2VuL2RvY3Mvc3ludGF4Lmh0bWwpJyxcbiAgICAgICAgICAnc28gcGxlYXNlIHVwZGF0ZSB5b3VyIGNvbmZpZyBhY2NvcmRpbmdseScsXG4gICAgICAgIF0uam9pbignXFxuJylcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gYSBidW5jaCBvZiBkaWZmZXJlbnQgY29uZmlndXJhYmxlIHRpbWVyc1xuICAgIHRoaXMubWF4YWdlID0gcGFyc2VJbnRlcnZhbChzZXRDb25maWcodGhpcy5jb25maWcsICdtYXhhZ2UnLCAnMm0nKSk7XG4gICAgdGhpcy50aW1lb3V0ID0gcGFyc2VJbnRlcnZhbChzZXRDb25maWcodGhpcy5jb25maWcsICd0aW1lb3V0JywgJzMwcycpKTtcbiAgICB0aGlzLm1heF9mYWlscyA9IE51bWJlcihzZXRDb25maWcodGhpcy5jb25maWcsICdtYXhfZmFpbHMnLCAyKSk7XG4gICAgdGhpcy5mYWlsX3RpbWVvdXQgPSBwYXJzZUludGVydmFsKHNldENvbmZpZyh0aGlzLmNvbmZpZywgJ2ZhaWxfdGltZW91dCcsICc1bScpKTtcbiAgICB0aGlzLnN0cmljdF9zc2wgPSBCb29sZWFuKHNldENvbmZpZyh0aGlzLmNvbmZpZywgJ3N0cmljdF9zc2wnLCB0cnVlKSk7XG4gICAgdGhpcy5hZ2VudF9vcHRpb25zID0gc2V0Q29uZmlnKHRoaXMuY29uZmlnLCAnYWdlbnRfb3B0aW9ucycsIHtcbiAgICAgIGtlZXBBbGl2ZTogdHJ1ZSxcbiAgICAgIG1heFNvY2tldHM6IDQwLFxuICAgICAgbWF4RnJlZVNvY2tldHM6IDEwLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGFuIGFzc2V0LlxuICAgKiBAcGFyYW0geyp9IG9wdGlvbnNcbiAgICogQHBhcmFtIHsqfSBjYlxuICAgKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICAgKi9cbiAgcHJpdmF0ZSByZXF1ZXN0KG9wdGlvbnM6IGFueSwgY2I/OiBDYWxsYmFjayk6IFN0cmVhbS5SZWFkYWJsZSB7XG4gICAgbGV0IGpzb247XG5cbiAgICBpZiAodGhpcy5fc3RhdHVzQ2hlY2soKSA9PT0gZmFsc2UpIHtcbiAgICAgIGNvbnN0IHN0cmVhbVJlYWQgPSBuZXcgU3RyZWFtLlJlYWRhYmxlKCk7XG5cbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCk6IHZvaWQge1xuICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICBjYihFcnJvckNvZGUuZ2V0SW50ZXJuYWxFcnJvcihBUElfRVJST1IuVVBMSU5LX09GRkxJTkUpKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW1SZWFkLmVtaXQoJ2Vycm9yJywgRXJyb3JDb2RlLmdldEludGVybmFsRXJyb3IoQVBJX0VSUk9SLlVQTElOS19PRkZMSU5FKSk7XG4gICAgICB9KTtcblxuICAgICAgc3RyZWFtUmVhZC5fcmVhZCA9IGZ1bmN0aW9uICgpOiB2b2lkIHt9O1xuICAgICAgLy8gcHJldmVudGluZyAnVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudCdcbiAgICAgIHN0cmVhbVJlYWQub24oJ2Vycm9yJywgZnVuY3Rpb24gKCk6IHZvaWQge30pO1xuICAgICAgcmV0dXJuIHN0cmVhbVJlYWQ7XG4gICAgfVxuXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgY29uc3QgaGVhZGVyczogSGVhZGVycyA9IHRoaXMuX3NldEhlYWRlcnMob3B0aW9ucyk7XG5cbiAgICB0aGlzLl9hZGRQcm94eUhlYWRlcnMob3B0aW9ucy5yZXEsIGhlYWRlcnMpO1xuICAgIHRoaXMuX292ZXJyaWRlV2l0aFVwTGlua0NvbmZpZ0hlYWRlcnMoaGVhZGVycyk7XG5cbiAgICBjb25zdCBtZXRob2QgPSBvcHRpb25zLm1ldGhvZCB8fCAnR0VUJztcbiAgICBjb25zdCB1cmkgPSBvcHRpb25zLnVyaV9mdWxsIHx8IHRoaXMuY29uZmlnLnVybCArIG9wdGlvbnMudXJpO1xuXG4gICAgc2VsZi5sb2dnZXIuaW5mbyhcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgIHVyaTogdXJpLFxuICAgICAgfSxcbiAgICAgIFwibWFraW5nIHJlcXVlc3Q6ICdAe21ldGhvZH0gQHt1cml9J1wiXG4gICAgKTtcblxuICAgIGlmIChpc09iamVjdChvcHRpb25zLmpzb24pKSB7XG4gICAgICBqc29uID0gSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5qc29uKTtcbiAgICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gaGVhZGVyc1snQ29udGVudC1UeXBlJ10gfHwgSEVBREVSUy5KU09OO1xuICAgIH1cblxuICAgIGNvbnN0IHJlcXVlc3RDYWxsYmFjayA9IGNiXG4gICAgICA/IGZ1bmN0aW9uIChlcnIsIHJlcywgYm9keSk6IHZvaWQge1xuICAgICAgICAgIGxldCBlcnJvcjtcbiAgICAgICAgICBjb25zdCByZXNwb25zZUxlbmd0aCA9IGVyciA/IDAgOiBib2R5Lmxlbmd0aDtcblxuICAgICAgICAgIHByb2Nlc3NCb2R5KCk7XG4gICAgICAgICAgbG9nQWN0aXZpdHkoKTtcblxuICAgICAgICAgIGNiKGVyciwgcmVzLCBib2R5KTtcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFBlcmZvcm0gYSBkZWNvZGUuXG4gICAgICAgICAgICovXG4gICAgICAgICAgZnVuY3Rpb24gcHJvY2Vzc0JvZHkoKTogdm9pZCB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgIGVycm9yID0gZXJyLm1lc3NhZ2U7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuanNvbiAmJiByZXMuc3RhdHVzQ29kZSA8IDMwMCkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBKU09OLnBhcnNlKGJvZHkudG9TdHJpbmcoQ0hBUkFDVEVSX0VOQ09ESU5HLlVURjgpKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoX2Vycikge1xuICAgICAgICAgICAgICAgIGJvZHkgPSB7fTtcbiAgICAgICAgICAgICAgICBlcnIgPSBfZXJyO1xuICAgICAgICAgICAgICAgIGVycm9yID0gZXJyLm1lc3NhZ2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFlcnIgJiYgaXNPYmplY3QoYm9keSkpIHtcbiAgICAgICAgICAgICAgaWYgKF8uaXNTdHJpbmcoYm9keS5lcnJvcikpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IGJvZHkuZXJyb3I7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogUGVyZm9ybSBhIGxvZy5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBmdW5jdGlvbiBsb2dBY3Rpdml0eSgpOiB2b2lkIHtcbiAgICAgICAgICAgIGxldCBtZXNzYWdlID0gXCJAeyFzdGF0dXN9LCByZXE6ICdAe3JlcXVlc3QubWV0aG9kfSBAe3JlcXVlc3QudXJsfSdcIjtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gZXJyb3IgPyAnLCBlcnJvcjogQHshZXJyb3J9JyA6ICcsIGJ5dGVzOiBAe2J5dGVzLmlufS9Ae2J5dGVzLm91dH0nO1xuICAgICAgICAgICAgc2VsZi5sb2dnZXIuaHR0cChcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGVycjogZXJyIHx8IHVuZGVmaW5lZCwgLy8gaWYgZXJyb3IgaXMgbnVsbC9mYWxzZSBjaGFuZ2UgdGhpcyB0byB1bmRlZmluZWQgc28gaXQgd29udCBsb2dcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiB7IG1ldGhvZDogbWV0aG9kLCB1cmw6IHVyaSB9LFxuICAgICAgICAgICAgICAgIHN0YXR1czogcmVzICE9IG51bGwgPyByZXMuc3RhdHVzQ29kZSA6ICdFUlInLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICBieXRlczoge1xuICAgICAgICAgICAgICAgICAgaW46IGpzb24gPyBqc29uLmxlbmd0aCA6IDAsXG4gICAgICAgICAgICAgICAgICBvdXQ6IHJlc3BvbnNlTGVuZ3RoIHx8IDAsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgbWVzc2FnZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIDogdW5kZWZpbmVkO1xuICAgIGxldCByZXF1ZXN0T3B0aW9uczogcmVxdWVzdC5PcHRpb25zV2l0aFVybCA9IHtcbiAgICAgIHVybDogdXJpLFxuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgYm9keToganNvbixcbiAgICAgIHByb3h5OiB0aGlzLnByb3h5LFxuICAgICAgZW5jb2Rpbmc6IG51bGwsXG4gICAgICBnemlwOiB0cnVlLFxuICAgICAgdGltZW91dDogdGhpcy50aW1lb3V0LFxuICAgICAgc3RyaWN0U1NMOiB0aGlzLnN0cmljdF9zc2wsXG4gICAgICBhZ2VudE9wdGlvbnM6IHRoaXMuYWdlbnRfb3B0aW9ucyxcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMuY2EpIHtcbiAgICAgIHJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdE9wdGlvbnMsIHtcbiAgICAgICAgY2E6IHRoaXMuY2EsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCByZXEgPSByZXF1ZXN0KHJlcXVlc3RPcHRpb25zLCByZXF1ZXN0Q2FsbGJhY2spO1xuXG4gICAgbGV0IHN0YXR1c0NhbGxlZCA9IGZhbHNlO1xuICAgIHJlcS5vbigncmVzcG9uc2UnLCBmdW5jdGlvbiAocmVzKTogdm9pZCB7XG4gICAgICAvLyBGSVhNRTogX3ZlcmRhY2Npb19hYm9ydGVkIHNlZW1zIG5vdCB1c2VkXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBpZiAoIXJlcS5fdmVyZGFjY2lvX2Fib3J0ZWQgJiYgIXN0YXR1c0NhbGxlZCkge1xuICAgICAgICBzdGF0dXNDYWxsZWQgPSB0cnVlO1xuICAgICAgICBzZWxmLl9zdGF0dXNDaGVjayh0cnVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF8uaXNOaWwocmVxdWVzdENhbGxiYWNrKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgKGZ1bmN0aW9uIGRvX2xvZygpOiB2b2lkIHtcbiAgICAgICAgICBjb25zdCBtZXNzYWdlID0gXCJAeyFzdGF0dXN9LCByZXE6ICdAe3JlcXVlc3QubWV0aG9kfSBAe3JlcXVlc3QudXJsfScgKHN0cmVhbWluZylcIjtcbiAgICAgICAgICBzZWxmLmxvZ2dlci5odHRwKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICByZXF1ZXN0OiB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgdXJsOiB1cmksXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHN0YXR1czogXy5pc051bGwocmVzKSA9PT0gZmFsc2UgPyByZXMuc3RhdHVzQ29kZSA6ICdFUlInLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1lc3NhZ2VcbiAgICAgICAgICApO1xuICAgICAgICB9KSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJlcS5vbignZXJyb3InLCBmdW5jdGlvbiAoX2Vycik6IHZvaWQge1xuICAgICAgLy8gRklYTUU6IF92ZXJkYWNjaW9fYWJvcnRlZCBzZWVtcyBub3QgdXNlZFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgaWYgKCFyZXEuX3ZlcmRhY2Npb19hYm9ydGVkICYmICFzdGF0dXNDYWxsZWQpIHtcbiAgICAgICAgc3RhdHVzQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgc2VsZi5fc3RhdHVzQ2hlY2soZmFsc2UpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gcmVxO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBkZWZhdWx0IGhlYWRlcnMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgX3NldEhlYWRlcnMob3B0aW9uczogYW55KTogSGVhZGVycyB7XG4gICAgY29uc3QgaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycyB8fCB7fTtcbiAgICBjb25zdCBhY2NlcHQgPSBIRUFERVJTLkFDQ0VQVDtcbiAgICBjb25zdCBhY2NlcHRFbmNvZGluZyA9IEhFQURFUlMuQUNDRVBUX0VOQ09ESU5HO1xuICAgIGNvbnN0IHVzZXJBZ2VudCA9IEhFQURFUlMuVVNFUl9BR0VOVDtcblxuICAgIGhlYWRlcnNbYWNjZXB0XSA9IGhlYWRlcnNbYWNjZXB0XSB8fCBjb250ZW50VHlwZUFjY2VwdDtcbiAgICBoZWFkZXJzW2FjY2VwdEVuY29kaW5nXSA9IGhlYWRlcnNbYWNjZXB0RW5jb2RpbmddIHx8ICdnemlwJztcbiAgICAvLyByZWdpc3RyeS5ucG1qcy5vcmcgd2lsbCBvbmx5IHJldHVybiBzZWFyY2ggcmVzdWx0IGlmIHVzZXItYWdlbnQgaW5jbHVkZSBzdHJpbmcgJ25wbSdcbiAgICBoZWFkZXJzW3VzZXJBZ2VudF0gPSB0aGlzLnVzZXJBZ2VudFxuICAgICAgPyBgbnBtICgke3RoaXMudXNlckFnZW50fSlgXG4gICAgICA6IG9wdGlvbnMucmVxPy5nZXQoJ3VzZXItYWdlbnQnKTtcblxuICAgIHJldHVybiB0aGlzLl9zZXRBdXRoKGhlYWRlcnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIGNvbmZpZ3VyYXRpb24gYXV0aCBhbmQgYXNzaWduIEhlYWRlciBhdXRob3JpemF0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXJzXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgX3NldEF1dGgoaGVhZGVyczogYW55KTogSGVhZGVycyB7XG4gICAgY29uc3QgeyBhdXRoIH0gPSB0aGlzLmNvbmZpZztcblxuICAgIGlmIChfLmlzTmlsKGF1dGgpIHx8IGhlYWRlcnNbSEVBREVSUy5BVVRIT1JJWkFUSU9OXSkge1xuICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuXG4gICAgaWYgKF8uaXNPYmplY3QoYXV0aCkgPT09IGZhbHNlICYmIF8uaXNPYmplY3QoYXV0aC50b2tlbikgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLl90aHJvd0Vycm9yQXV0aCgnQXV0aCBpbnZhbGlkJyk7XG4gICAgfVxuXG4gICAgLy8gZ2V0IE5QTV9UT0tFTiBodHRwOi8vYmxvZy5ucG1qcy5vcmcvcG9zdC8xMTgzOTMzNjg1NTUvZGVwbG95aW5nLXdpdGgtbnBtLXByaXZhdGUtbW9kdWxlc1xuICAgIC8vIG9yIGdldCBvdGhlciB2YXJpYWJsZSBleHBvcnQgaW4gZW52XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3ZlcmRhY2Npby92ZXJkYWNjaW8vcmVsZWFzZXMvdGFnL3YyLjUuMFxuICAgIGxldCB0b2tlbjogYW55O1xuICAgIGNvbnN0IHRva2VuQ29uZjogYW55ID0gYXV0aDtcblxuICAgIGlmIChfLmlzTmlsKHRva2VuQ29uZi50b2tlbikgPT09IGZhbHNlICYmIF8uaXNTdHJpbmcodG9rZW5Db25mLnRva2VuKSkge1xuICAgICAgdG9rZW4gPSB0b2tlbkNvbmYudG9rZW47XG4gICAgfSBlbHNlIGlmIChfLmlzTmlsKHRva2VuQ29uZi50b2tlbl9lbnYpID09PSBmYWxzZSkge1xuICAgICAgaWYgKF8uaXNTdHJpbmcodG9rZW5Db25mLnRva2VuX2VudikpIHtcbiAgICAgICAgdG9rZW4gPSBwcm9jZXNzLmVudlt0b2tlbkNvbmYudG9rZW5fZW52XTtcbiAgICAgIH0gZWxzZSBpZiAoXy5pc0Jvb2xlYW4odG9rZW5Db25mLnRva2VuX2VudikgJiYgdG9rZW5Db25mLnRva2VuX2Vudikge1xuICAgICAgICB0b2tlbiA9IHByb2Nlc3MuZW52Lk5QTV9UT0tFTjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKEVSUk9SX0NPREUudG9rZW5fcmVxdWlyZWQpO1xuICAgICAgICB0aGlzLl90aHJvd0Vycm9yQXV0aChFUlJPUl9DT0RFLnRva2VuX3JlcXVpcmVkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdG9rZW4gPSBwcm9jZXNzLmVudi5OUE1fVE9LRU47XG4gICAgfVxuXG4gICAgaWYgKF8uaXNOaWwodG9rZW4pKSB7XG4gICAgICB0aGlzLl90aHJvd0Vycm9yQXV0aChFUlJPUl9DT0RFLnRva2VuX3JlcXVpcmVkKTtcbiAgICB9XG5cbiAgICAvLyBkZWZpbmUgdHlwZSBBdXRoIGFsbG93IGJhc2ljIGFuZCBiZWFyZXJcbiAgICBjb25zdCB0eXBlID0gdG9rZW5Db25mLnR5cGUgfHwgVE9LRU5fQkFTSUM7XG4gICAgdGhpcy5fc2V0SGVhZGVyQXV0aG9yaXphdGlvbihoZWFkZXJzLCB0eXBlLCB0b2tlbik7XG5cbiAgICByZXR1cm4gaGVhZGVycztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxuICAgKiBAdGhyb3dzIHtFcnJvcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgX3Rocm93RXJyb3JBdXRoKG1lc3NhZ2U6IHN0cmluZyk6IEVycm9yIHtcbiAgICB0aGlzLmxvZ2dlci5lcnJvcihtZXNzYWdlKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cblxuICAvKipcbiAgICogQXNzaWduIEhlYWRlciBhdXRob3JpemF0aW9uIHdpdGggdHlwZSBhdXRoZW50aWNhdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gaGVhZGVyc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgX3NldEhlYWRlckF1dGhvcml6YXRpb24oaGVhZGVyczogYW55LCB0eXBlOiBzdHJpbmcsIHRva2VuOiBhbnkpOiB2b2lkIHtcbiAgICBjb25zdCBfdHlwZTogc3RyaW5nID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgaWYgKF90eXBlICE9PSBUT0tFTl9CRUFSRVIudG9Mb3dlckNhc2UoKSAmJiBfdHlwZSAhPT0gVE9LRU5fQkFTSUMudG9Mb3dlckNhc2UoKSkge1xuICAgICAgdGhpcy5fdGhyb3dFcnJvckF1dGgoYEF1dGggdHlwZSAnJHtfdHlwZX0nIG5vdCBhbGxvd2VkYCk7XG4gICAgfVxuXG4gICAgdHlwZSA9IF8udXBwZXJGaXJzdCh0eXBlKTtcbiAgICBoZWFkZXJzW0hFQURFUlMuQVVUSE9SSVpBVElPTl0gPSBidWlsZFRva2VuKHR5cGUsIHRva2VuKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJdCB3aWxsIGFkZCBvciBvdmVycmlkZSBzcGVjaWZpZWQgaGVhZGVycyBmcm9tIGNvbmZpZyBmaWxlLlxuICAgKlxuICAgKiBFZzpcbiAgICpcbiAgICogdXBsaW5rczpcbiAgIG5wbWpzOlxuICAgdXJsOiBodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy9cbiAgIGhlYWRlcnM6XG4gICBBY2NlcHQ6IFwiYXBwbGljYXRpb24vdm5kLm5wbS5pbnN0YWxsLXYyK2pzb247IHE9MS4wXCJcbiAgIHZlcmRhY2Npby1zdGFnaW5nOlxuICAgdXJsOiBodHRwczovL215Y29tcGFueS5jb20vbnBtXG4gICBoZWFkZXJzOlxuICAgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgYXV0aG9yaXphdGlvbjogXCJCYXNpYyBZb3VyQmFzZTY0RW5jb2RlZENyZWRlbnRpYWxzPT1cIlxuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXJzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIF9vdmVycmlkZVdpdGhVcExpbmtDb25maWdIZWFkZXJzKGhlYWRlcnM6IEhlYWRlcnMpOiBhbnkge1xuICAgIGlmICghdGhpcy5jb25maWcuaGVhZGVycykge1xuICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuXG4gICAgLy8gYWRkL292ZXJyaWRlIGhlYWRlcnMgc3BlY2lmaWVkIGluIHRoZSBjb25maWdcbiAgICAvKiBlc2xpbnQgZ3VhcmQtZm9yLWluOiAwICovXG4gICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5jb25maWcuaGVhZGVycykge1xuICAgICAgaGVhZGVyc1trZXldID0gdGhpcy5jb25maWcuaGVhZGVyc1trZXldO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgd2hldGhlciBjYW4gZmV0Y2ggZnJvbSB0aGUgcHJvdmlkZWQgVVJMXG4gICAqIEBwYXJhbSB7Kn0gdXJsXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBwdWJsaWMgaXNVcGxpbmtWYWxpZCh1cmw6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHVybFBhcnNlZDogVXJsV2l0aFN0cmluZ1F1ZXJ5ID0gVVJMLnBhcnNlKHVybCk7XG4gICAgY29uc3QgaXNIVFRQUyA9ICh1cmxEb21haW5QYXJzZWQ6IFVSTCk6IGJvb2xlYW4gPT5cbiAgICAgIHVybERvbWFpblBhcnNlZC5wcm90b2NvbCA9PT0gJ2h0dHBzOicgJiZcbiAgICAgICh1cmxQYXJzZWQucG9ydCA9PT0gbnVsbCB8fCB1cmxQYXJzZWQucG9ydCA9PT0gJzQ0MycpO1xuICAgIGNvbnN0IGdldEhvc3QgPSAodXJsRG9tYWluUGFyc2VkKTogYm9vbGVhbiA9PlxuICAgICAgaXNIVFRQUyh1cmxEb21haW5QYXJzZWQpID8gdXJsRG9tYWluUGFyc2VkLmhvc3RuYW1lIDogdXJsRG9tYWluUGFyc2VkLmhvc3Q7XG4gICAgY29uc3QgaXNNYXRjaFByb3RvY29sOiBib29sZWFuID0gdXJsUGFyc2VkLnByb3RvY29sID09PSB0aGlzLnVybC5wcm90b2NvbDtcbiAgICBjb25zdCBpc01hdGNoSG9zdDogYm9vbGVhbiA9IGdldEhvc3QodXJsUGFyc2VkKSA9PT0gZ2V0SG9zdCh0aGlzLnVybCk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IGlzTWF0Y2hQYXRoOiBib29sZWFuID0gdXJsUGFyc2VkLnBhdGguaW5kZXhPZih0aGlzLnVybC5wYXRoKSA9PT0gMDtcblxuICAgIHJldHVybiBpc01hdGNoUHJvdG9jb2wgJiYgaXNNYXRjaEhvc3QgJiYgaXNNYXRjaFBhdGg7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgcmVtb3RlIHBhY2thZ2UgbWV0YWRhdGFcbiAgICogQHBhcmFtIHsqfSBuYW1lIHBhY2thZ2UgbmFtZVxuICAgKiBAcGFyYW0geyp9IG9wdGlvbnMgcmVxdWVzdCBvcHRpb25zLCBlZzogZVRhZy5cbiAgICogQHBhcmFtIHsqfSBjYWxsYmFja1xuICAgKi9cbiAgcHVibGljIGdldFJlbW90ZU1ldGFkYXRhKG5hbWU6IHN0cmluZywgb3B0aW9uczogYW55LCBjYWxsYmFjazogQ2FsbGJhY2spOiB2b2lkIHtcbiAgICBjb25zdCBoZWFkZXJzID0ge307XG4gICAgaWYgKF8uaXNOaWwob3B0aW9ucy5ldGFnKSA9PT0gZmFsc2UpIHtcbiAgICAgIGhlYWRlcnNbJ0lmLU5vbmUtTWF0Y2gnXSA9IG9wdGlvbnMuZXRhZztcbiAgICAgIGhlYWRlcnNbSEVBREVSUy5BQ0NFUFRdID0gY29udGVudFR5cGVBY2NlcHQ7XG4gICAgfVxuXG4gICAgdGhpcy5yZXF1ZXN0KFxuICAgICAge1xuICAgICAgICB1cmk6IGAvJHtlbmNvZGUobmFtZSl9YCxcbiAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgICAgcmVxOiBvcHRpb25zLnJlcSxcbiAgICAgIH0sXG4gICAgICAoZXJyLCByZXMsIGJvZHkpOiB2b2lkID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXMuc3RhdHVzQ29kZSA9PT0gSFRUUF9TVEFUVVMuTk9UX0ZPVU5EKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKEVycm9yQ29kZS5nZXROb3RGb3VuZChBUElfRVJST1IuTk9UX1BBQ0tBR0VfVVBMSU5LKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEocmVzLnN0YXR1c0NvZGUgPj0gSFRUUF9TVEFUVVMuT0sgJiYgcmVzLnN0YXR1c0NvZGUgPCBIVFRQX1NUQVRVUy5NVUxUSVBMRV9DSE9JQ0VTKSkge1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gRXJyb3JDb2RlLmdldEludGVybmFsRXJyb3IoXG4gICAgICAgICAgICBgJHtBUElfRVJST1IuQkFEX1NUQVRVU19DT0RFfTogJHtyZXMuc3RhdHVzQ29kZX1gXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGVycm9yLnJlbW90ZVN0YXR1cyA9IHJlcy5zdGF0dXNDb2RlO1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2sobnVsbCwgYm9keSwgcmVzLmhlYWRlcnMuZXRhZyk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhIHRhcmJhbGwgZnJvbSB0aGUgdXBsaW5rLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gICAqIEByZXR1cm4ge1N0cmVhbX1cbiAgICovXG4gIHB1YmxpYyBmZXRjaFRhcmJhbGwodXJsOiBzdHJpbmcpIHtcbiAgICBjb25zdCBzdHJlYW0gPSBuZXcgUmVhZFRhcmJhbGwoe30pO1xuICAgIGxldCBjdXJyZW50X2xlbmd0aCA9IDA7XG4gICAgbGV0IGV4cGVjdGVkX2xlbmd0aDtcblxuICAgIHN0cmVhbS5hYm9ydCA9ICgpID0+IHt9O1xuICAgIGNvbnN0IHJlYWRTdHJlYW0gPSB0aGlzLnJlcXVlc3Qoe1xuICAgICAgdXJpX2Z1bGw6IHVybCxcbiAgICAgIGVuY29kaW5nOiBudWxsLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBBY2NlcHQ6IGNvbnRlbnRUeXBlQWNjZXB0LFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIHJlYWRTdHJlYW0ub24oJ3Jlc3BvbnNlJywgZnVuY3Rpb24gKHJlczogYW55KSB7XG4gICAgICBpZiAocmVzLnN0YXR1c0NvZGUgPT09IEhUVFBfU1RBVFVTLk5PVF9GT1VORCkge1xuICAgICAgICByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgRXJyb3JDb2RlLmdldE5vdEZvdW5kKEFQSV9FUlJPUi5OT1RfRklMRV9VUExJTkspKTtcbiAgICAgIH1cbiAgICAgIGlmICghKHJlcy5zdGF0dXNDb2RlID49IEhUVFBfU1RBVFVTLk9LICYmIHJlcy5zdGF0dXNDb2RlIDwgSFRUUF9TVEFUVVMuTVVMVElQTEVfQ0hPSUNFUykpIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbS5lbWl0KFxuICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgRXJyb3JDb2RlLmdldEludGVybmFsRXJyb3IoYGJhZCB1cGxpbmsgc3RhdHVzIGNvZGU6ICR7cmVzLnN0YXR1c0NvZGV9YClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXMuaGVhZGVyc1tIRUFERVJfVFlQRS5DT05URU5UX0xFTkdUSF0pIHtcbiAgICAgICAgZXhwZWN0ZWRfbGVuZ3RoID0gcmVzLmhlYWRlcnNbSEVBREVSX1RZUEUuQ09OVEVOVF9MRU5HVEhdO1xuICAgICAgICBzdHJlYW0uZW1pdChIRUFERVJfVFlQRS5DT05URU5UX0xFTkdUSCwgcmVzLmhlYWRlcnNbSEVBREVSX1RZUEUuQ09OVEVOVF9MRU5HVEhdKTtcbiAgICAgIH1cblxuICAgICAgcmVhZFN0cmVhbS5waXBlKHN0cmVhbSk7XG4gICAgfSk7XG5cbiAgICByZWFkU3RyZWFtLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfSk7XG4gICAgcmVhZFN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICBjdXJyZW50X2xlbmd0aCArPSBkYXRhLmxlbmd0aDtcbiAgICB9KTtcbiAgICByZWFkU3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgY3VycmVudF9sZW5ndGggKz0gZGF0YS5sZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAoZXhwZWN0ZWRfbGVuZ3RoICYmIGN1cnJlbnRfbGVuZ3RoICE9IGV4cGVjdGVkX2xlbmd0aCkge1xuICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBFcnJvckNvZGUuZ2V0SW50ZXJuYWxFcnJvcihBUElfRVJST1IuQ09OVEVOVF9NSVNNQVRDSCkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzdHJlYW07XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybSBhIHN0cmVhbSBzZWFyY2guXG4gICAqIEBwYXJhbSB7Kn0gb3B0aW9ucyByZXF1ZXN0IG9wdGlvbnNcbiAgICogQHJldHVybiB7U3RyZWFtfVxuICAgKi9cbiAgcHVibGljIHNlYXJjaChvcHRpb25zOiBhbnkpIHtcbiAgICBjb25zdCB0cmFuc2Zvcm1TdHJlYW06IGFueSA9IG5ldyBTdHJlYW0uUGFzc1Rocm91Z2goeyBvYmplY3RNb2RlOiB0cnVlIH0pO1xuICAgIGNvbnN0IHJlcXVlc3RTdHJlYW06IFN0cmVhbS5SZWFkYWJsZSA9IHRoaXMucmVxdWVzdCh7XG4gICAgICB1cmk6IG9wdGlvbnMucmVxLnVybCxcbiAgICAgIHJlcTogb3B0aW9ucy5yZXEsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIC8vIHF1ZXJ5IGZvciBzZWFyY2hcbiAgICAgICAgcmVmZXJlcjogb3B0aW9ucy5yZXEuZ2V0KCdyZWZlcmVyJyksXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgY29uc3QgcGFyc2VQYWNrYWdlID0gKHBrZzogUGFja2FnZSk6IHZvaWQgPT4ge1xuICAgICAgaWYgKGlzT2JqZWN0T3JBcnJheShwa2cpKSB7XG4gICAgICAgIHRyYW5zZm9ybVN0cmVhbS5lbWl0KCdkYXRhJywgcGtnKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmVxdWVzdFN0cmVhbS5vbigncmVzcG9uc2UnLCAocmVzKTogdm9pZCA9PiB7XG4gICAgICBpZiAoIVN0cmluZyhyZXMuc3RhdHVzQ29kZSkubWF0Y2goL14yXFxkXFxkJC8pKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1TdHJlYW0uZW1pdChcbiAgICAgICAgICAnZXJyb3InLFxuICAgICAgICAgIEVycm9yQ29kZS5nZXRJbnRlcm5hbEVycm9yKGBiYWQgc3RhdHVzIGNvZGUgJHtyZXMuc3RhdHVzQ29kZX0gZnJvbSB1cGxpbmtgKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlcXVlc3QvcmVxdWVzdCNyZXF1ZXN0b3B0aW9ucy1jYWxsYmFja1xuICAgICAgLy8gUmVxdWVzdCBsaWJyYXJ5IHdpbGwgbm90IGRlY29kZSBnemlwIHN0cmVhbS5cbiAgICAgIGxldCBqc29uU3RyZWFtO1xuICAgICAgaWYgKHJlcy5oZWFkZXJzW0hFQURFUl9UWVBFLkNPTlRFTlRfRU5DT0RJTkddID09PSBIRUFERVJTLkdaSVApIHtcbiAgICAgICAganNvblN0cmVhbSA9IHJlcy5waXBlKHpsaWIuY3JlYXRlVW56aXAoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBqc29uU3RyZWFtID0gcmVzO1xuICAgICAgfVxuICAgICAganNvblN0cmVhbS5waXBlKEpTT05TdHJlYW0ucGFyc2UoJyonKSkub24oJ2RhdGEnLCBwYXJzZVBhY2thZ2UpO1xuICAgICAganNvblN0cmVhbS5vbignZW5kJywgKCk6IHZvaWQgPT4ge1xuICAgICAgICB0cmFuc2Zvcm1TdHJlYW0uZW1pdCgnZW5kJyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJlcXVlc3RTdHJlYW0ub24oJ2Vycm9yJywgKGVycjogRXJyb3IpOiB2b2lkID0+IHtcbiAgICAgIHRyYW5zZm9ybVN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfSk7XG5cbiAgICB0cmFuc2Zvcm1TdHJlYW0uYWJvcnQgPSAoKTogdm9pZCA9PiB7XG4gICAgICAvLyBGSVhNRTogdGhpcyBpcyBjbGVhcmx5IGEgcG90ZW50aWFsIGlzc3VlXG4gICAgICAvLyB0aGVyZSBpcyBubyBhYm9ydCBtZXRob2Qgb24gU3RyZWFtLlJlYWRhYmxlXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICByZXF1ZXN0U3RyZWFtLmFib3J0KCk7XG4gICAgICB0cmFuc2Zvcm1TdHJlYW0uZW1pdCgnZW5kJyk7XG4gICAgfTtcblxuICAgIHJldHVybiB0cmFuc2Zvcm1TdHJlYW07XG4gIH1cblxuICAvKipcbiAgICogQWRkIHByb3h5IGhlYWRlcnMuXG4gICAqIEZJWE1FOiBvYmplY3QgbXV0YXRpb25zLCBpdCBzaG91bGQgcmV0dXJuIGFuIG5ldyBvYmplY3RcbiAgICogQHBhcmFtIHsqfSByZXEgdGhlIGh0dHAgcmVxdWVzdFxuICAgKiBAcGFyYW0geyp9IGhlYWRlcnMgdGhlIHJlcXVlc3QgaGVhZGVyc1xuICAgKi9cbiAgcHJpdmF0ZSBfYWRkUHJveHlIZWFkZXJzKHJlcTogYW55LCBoZWFkZXJzOiBhbnkpOiB2b2lkIHtcbiAgICBpZiAocmVxKSB7XG4gICAgICAvLyBPbmx5IHN1Ym1pdCBYLUZvcndhcmRlZC1Gb3IgZmllbGQgaWYgd2UgZG9uJ3QgaGF2ZSBhIHByb3h5IHNlbGVjdGVkXG4gICAgICAvLyBpbiB0aGUgY29uZmlnIGZpbGUuXG4gICAgICAvL1xuICAgICAgLy8gT3RoZXJ3aXNlIG1pc2NvbmZpZ3VyZWQgcHJveHkgY291bGQgcmV0dXJuIDQwNzpcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ybGlkd2thL3Npbm9waWEvaXNzdWVzLzI1NFxuICAgICAgLy9cbiAgICAgIC8vIEZJWE1FOiBwcm94eSBsb2dpYyBpcyBvZGQsIHNvbWV0aGluZyBpcyB3cm9uZyBoZXJlLlxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgaWYgKCF0aGlzLnByb3h5KSB7XG4gICAgICAgIGhlYWRlcnNbJ3gtZm9yd2FyZGVkLWZvciddID1cbiAgICAgICAgICAocmVxLmdldCgneC1mb3J3YXJkZWQtZm9yJykgPyByZXEuZ2V0KCd4LWZvcndhcmRlZC1mb3InKSArICcsICcgOiAnJykgK1xuICAgICAgICAgIHJlcS5jb25uZWN0aW9uLnJlbW90ZUFkZHJlc3M7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWx3YXlzIGF0dGFjaCBWaWEgaGVhZGVyIHRvIGF2b2lkIGxvb3BzLCBldmVuIGlmIHdlJ3JlIG5vdCBwcm94eWluZ1xuICAgIGhlYWRlcnNbJ3ZpYSddID0gcmVxICYmIHJlcS5nZXQoJ3ZpYScpID8gcmVxLmdldCgndmlhJykgKyAnLCAnIDogJyc7XG5cbiAgICBoZWFkZXJzWyd2aWEnXSArPSAnMS4xICcgKyB0aGlzLnNlcnZlcl9pZCArICcgKFZlcmRhY2NpbyknO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgdGhlIHJlbW90ZSBob3N0IGlzIGF2YWlsYWJsZS5cbiAgICogQHBhcmFtIHsqfSBhbGl2ZVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgcHJpdmF0ZSBfc3RhdHVzQ2hlY2soYWxpdmU/OiBib29sZWFuKTogYm9vbGVhbiB8IHZvaWQge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5faWZSZXF1ZXN0RmFpbHVyZSgpID09PSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGFsaXZlKSB7XG4gICAgICBpZiAodGhpcy5mYWlsZWRfcmVxdWVzdHMgPj0gdGhpcy5tYXhfZmFpbHMpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihcbiAgICAgICAgICB7XG4gICAgICAgICAgICBob3N0OiB0aGlzLnVybC5ob3N0LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgJ2hvc3QgQHtob3N0fSBpcyBiYWNrIG9ubGluZSdcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZmFpbGVkX3JlcXVlc3RzID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5mYWlsZWRfcmVxdWVzdHMrKztcbiAgICAgIGlmICh0aGlzLmZhaWxlZF9yZXF1ZXN0cyA9PT0gdGhpcy5tYXhfZmFpbHMpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihcbiAgICAgICAgICB7XG4gICAgICAgICAgICBob3N0OiB0aGlzLnVybC5ob3N0LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgJ2hvc3QgQHtob3N0fSBpcyBub3cgb2ZmbGluZSdcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmxhc3RfcmVxdWVzdF90aW1lID0gRGF0ZS5ub3coKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB0aGUgcmVxdWVzdCBmYWlsdXJlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBfaWZSZXF1ZXN0RmFpbHVyZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5mYWlsZWRfcmVxdWVzdHMgPj0gdGhpcy5tYXhfZmFpbHMgJiZcbiAgICAgIE1hdGguYWJzKERhdGUubm93KCkgLSAodGhpcy5sYXN0X3JlcXVlc3RfdGltZSBhcyBudW1iZXIpKSA8IHRoaXMuZmFpbF90aW1lb3V0XG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdXAgYSBwcm94eS5cbiAgICogQHBhcmFtIHsqfSBob3N0bmFtZVxuICAgKiBAcGFyYW0geyp9IGNvbmZpZ1xuICAgKiBAcGFyYW0geyp9IG1haW5jb25maWdcbiAgICogQHBhcmFtIHsqfSBpc0hUVFBTXG4gICAqL1xuICBwcml2YXRlIF9zZXR1cFByb3h5KFxuICAgIGhvc3RuYW1lOiBzdHJpbmcsXG4gICAgY29uZmlnOiBVcExpbmtDb25mLFxuICAgIG1haW5jb25maWc6IENvbmZpZyxcbiAgICBpc0hUVFBTOiBib29sZWFuXG4gICk6IHZvaWQge1xuICAgIGxldCBub1Byb3h5TGlzdDtcbiAgICBjb25zdCBwcm94eV9rZXk6IHN0cmluZyA9IGlzSFRUUFMgPyAnaHR0cHNfcHJveHknIDogJ2h0dHBfcHJveHknO1xuXG4gICAgLy8gZ2V0IGh0dHBfcHJveHkgYW5kIG5vX3Byb3h5IGNvbmZpZ3NcbiAgICBpZiAocHJveHlfa2V5IGluIGNvbmZpZykge1xuICAgICAgdGhpcy5wcm94eSA9IGNvbmZpZ1twcm94eV9rZXldO1xuICAgIH0gZWxzZSBpZiAocHJveHlfa2V5IGluIG1haW5jb25maWcpIHtcbiAgICAgIHRoaXMucHJveHkgPSBtYWluY29uZmlnW3Byb3h5X2tleV07XG4gICAgfVxuICAgIGlmICgnbm9fcHJveHknIGluIGNvbmZpZykge1xuICAgICAgbm9Qcm94eUxpc3QgPSBjb25maWcubm9fcHJveHk7XG4gICAgfSBlbHNlIGlmICgnbm9fcHJveHknIGluIG1haW5jb25maWcpIHtcbiAgICAgIG5vUHJveHlMaXN0ID0gbWFpbmNvbmZpZy5ub19wcm94eTtcbiAgICB9XG5cbiAgICAvLyB1c2Ugd2dldC1saWtlIGFsZ29yaXRobSB0byBkZXRlcm1pbmUgaWYgcHJveHkgc2hvdWxkbid0IGJlIHVzZWRcbiAgICBpZiAoaG9zdG5hbWVbMF0gIT09ICcuJykge1xuICAgICAgaG9zdG5hbWUgPSAnLicgKyBob3N0bmFtZTtcbiAgICB9XG5cbiAgICBpZiAoXy5pc1N0cmluZyhub1Byb3h5TGlzdCkgJiYgbm9Qcm94eUxpc3QubGVuZ3RoKSB7XG4gICAgICBub1Byb3h5TGlzdCA9IG5vUHJveHlMaXN0LnNwbGl0KCcsJyk7XG4gICAgfVxuXG4gICAgaWYgKF8uaXNBcnJheShub1Byb3h5TGlzdCkpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9Qcm94eUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG5vUHJveHlJdGVtID0gbm9Qcm94eUxpc3RbaV07XG4gICAgICAgIGlmIChub1Byb3h5SXRlbVswXSAhPT0gJy4nKSB7XG4gICAgICAgICAgbm9Qcm94eUl0ZW0gPSAnLicgKyBub1Byb3h5SXRlbTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9zdG5hbWUubGFzdEluZGV4T2Yobm9Qcm94eUl0ZW0pID09PSBob3N0bmFtZS5sZW5ndGggLSBub1Byb3h5SXRlbS5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAodGhpcy5wcm94eSkge1xuICAgICAgICAgICAgZGVidWcoJ25vdCB1c2luZyBwcm94eSBmb3IgJW8sIGV4Y2x1ZGVkIGJ5ICVvIHJ1bGUnLCB0aGlzLnVybC5ocmVmLCBub1Byb3h5SXRlbSk7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICB0aGlzLnByb3h5ID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgaXQncyBub24tc3RyaW5nIChpLmUuIFwiZmFsc2VcIiksIGRvbid0IHVzZSBpdFxuICAgIGlmIChfLmlzU3RyaW5nKHRoaXMucHJveHkpID09PSBmYWxzZSkge1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgZGVsZXRlIHRoaXMucHJveHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnKCd1c2luZyBwcm94eSAlbyBmb3IgJW8nLCB0aGlzLnVybC5ocmVmLCB0aGlzLnByb3h5KTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUHJveHlTdG9yYWdlO1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxJQUFBQSxXQUFBLEdBQUFDLHNCQUFBLENBQUFDLE9BQUE7QUFDQSxJQUFBQyxNQUFBLEdBQUFGLHNCQUFBLENBQUFDLE9BQUE7QUFDQSxJQUFBRSxPQUFBLEdBQUFILHNCQUFBLENBQUFDLE9BQUE7QUFDQSxJQUFBRyxRQUFBLEdBQUFKLHNCQUFBLENBQUFDLE9BQUE7QUFDQSxJQUFBSSxPQUFBLEdBQUFMLHNCQUFBLENBQUFDLE9BQUE7QUFDQSxJQUFBSyxJQUFBLEdBQUFOLHNCQUFBLENBQUFDLE9BQUE7QUFDQSxJQUFBTSxLQUFBLEdBQUFQLHNCQUFBLENBQUFDLE9BQUE7QUFFQSxJQUFBTyxRQUFBLEdBQUFQLE9BQUE7QUFFQSxJQUFBUSxNQUFBLEdBQUFSLE9BQUE7QUFFQSxJQUFBUyxVQUFBLEdBQUFULE9BQUE7QUFVQSxJQUFBVSxPQUFBLEdBQUFWLE9BQUE7QUFDQSxJQUFBVyxPQUFBLEdBQUFYLE9BQUE7QUFBOEUsU0FBQUQsdUJBQUFhLEdBQUEsV0FBQUEsR0FBQSxJQUFBQSxHQUFBLENBQUFDLFVBQUEsR0FBQUQsR0FBQSxLQUFBRSxPQUFBLEVBQUFGLEdBQUE7QUFBQSxTQUFBRyxnQkFBQUgsR0FBQSxFQUFBSSxHQUFBLEVBQUFDLEtBQUEsSUFBQUQsR0FBQSxHQUFBRSxjQUFBLENBQUFGLEdBQUEsT0FBQUEsR0FBQSxJQUFBSixHQUFBLElBQUFPLE1BQUEsQ0FBQUMsY0FBQSxDQUFBUixHQUFBLEVBQUFJLEdBQUEsSUFBQUMsS0FBQSxFQUFBQSxLQUFBLEVBQUFJLFVBQUEsUUFBQUMsWUFBQSxRQUFBQyxRQUFBLG9CQUFBWCxHQUFBLENBQUFJLEdBQUEsSUFBQUMsS0FBQSxXQUFBTCxHQUFBO0FBQUEsU0FBQU0sZUFBQU0sR0FBQSxRQUFBUixHQUFBLEdBQUFTLFlBQUEsQ0FBQUQsR0FBQSwyQkFBQVIsR0FB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