'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var types = require('@web3-wallets-kit/types');
var rxjs = require('rxjs');
var Web3ProvidersWs = require('web3-providers-ws');
var Web3ProvidersHttp = require('web3-providers-http');

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

// A type of promise-like that resolves synchronously and supports only one observer
var _iteratorSymbol = /*#__PURE__*/typeof Symbol !== "undefined" ? Symbol.iterator || (Symbol.iterator = /*#__PURE__*/Symbol("Symbol.iterator")) : "@@iterator"; // Asynchronously iterate through an object's values
var _asyncIteratorSymbol = /*#__PURE__*/typeof Symbol !== "undefined" ? Symbol.asyncIterator || (Symbol.asyncIterator = /*#__PURE__*/Symbol("Symbol.asyncIterator")) : "@@asyncIterator"; // Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing

function _catch(body, recover) {
  try {
    var result = body();
  } catch (e) {
    return recover(e);
  }

  if (result && result.then) {
    return result.then(void 0, recover);
  }

  return result;
} // Asynchronously await a promise and pass the result to a finally continuation

function _finallyRethrows(body, finalizer) {
  try {
    var result = body();
  } catch (e) {
    return finalizer(true, e);
  }

  if (result && result.then) {
    return result.then(finalizer.bind(null, false), finalizer.bind(null, true));
  }

  return finalizer(false, result);
} // Asynchronously await a promise and invoke a finally continuation that always overrides the result

var getChainId = function getChainId(connector) {
  try {
    return Promise.resolve(connector.getChainId()).then(function (chainId) {
      if (!chainId) {
        throw new Error('ChainID is not found, you need to choose a network in your wallet');
      }

      return chainId;
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var getAccount = function getAccount(connector) {
  try {
    return Promise.resolve(connector.getAccount()).then(function (account) {
      if (!account) {
        throw new Error('No Ethereum accounts found, you need to create an account in your wallet');
      }

      return account;
    });
  } catch (e) {
    return Promise.reject(e);
  }
};
var WebsocketProvider = Web3ProvidersWs;
var HttpProvider = Web3ProvidersHttp;
var Web3WalletsManager = /*#__PURE__*/function () {
  function Web3WalletsManager(options) {
    this.txWeb3 = new rxjs.BehaviorSubject(null);
    this.account = new rxjs.BehaviorSubject(null);
    this.chainId = new rxjs.BehaviorSubject(null);
    this.status = new rxjs.BehaviorSubject('disconnected');
    this.activeConnector = null;
    this.accountSubscription = null;
    this.chainIdSubscription = null;
    this.disconnectSubscription = null;
    this.options = _extends({}, options, {
      defaultProvider: _extends({
        network: 'mainnet'
      }, options.defaultProvider)
    });
    this.checkOptions();
    this.web3 = options.makeWeb3(this.getDefaultProvider());
    this.connect = this.connect.bind(this);
    this.disconnect = this.disconnect.bind(this);
    this.handleAccountChange = this.handleAccountChange.bind(this);
    this.handleChainIdChange = this.handleChainIdChange.bind(this);
    this.handleDisconnect = this.handleDisconnect.bind(this);
  }

  var _proto = Web3WalletsManager.prototype;

  _proto.connect = function connect(connector) {
    try {
      var _this2 = this;

      return Promise.resolve(_this2.disconnect()).then(function () {
        _this2.activeConnector = connector;
        var makeWeb3 = _this2.options.makeWeb3;
        return _catch(function () {
          _this2.status.next('pending');

          return Promise.resolve(connector.connect()).then(function (_ref) {
            var provider = _ref.provider;
            var web3 = makeWeb3(provider);

            _this2.txWeb3.next(web3);

            return Promise.resolve(getAccount(connector)).then(function (account) {
              _this2.account.next(account);

              return Promise.resolve(getChainId(connector)).then(function (chainId) {
                _this2.chainId.next(chainId);

                _this2.accountSubscription = connector.subscribeConnectAccount(_this2.handleAccountChange);
                _this2.chainIdSubscription = connector.subscribeChainId(_this2.handleChainIdChange);
                _this2.disconnectSubscription = connector.subscribeDisconnect(_this2.handleDisconnect);

                _this2.status.next('connected');

                return {
                  provider: provider,
                  account: account,
                  chainId: chainId
                };
              });
            });
          });
        }, function (error) {
          _this2.disconnect();

          throw error;
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.disconnect = function disconnect() {
    try {
      var _this4 = this;

      var _temp3 = _finallyRethrows(function () {
        function _temp(_this3$activeConnecto) {
          _this3$activeConnecto;
        }

        _this4.accountSubscription && _this4.accountSubscription.unsubscribe();
        _this4.chainIdSubscription && _this4.chainIdSubscription.unsubscribe();
        _this4.disconnectSubscription && _this4.disconnectSubscription.unsubscribe();
        var _this3$activeConnecto2 = _this4.activeConnector;
        return _this3$activeConnecto2 ? Promise.resolve(_this4.activeConnector.disconnect()).then(_temp) : _temp(_this3$activeConnecto2);
      }, function (_wasThrown, _result) {
        _this4.resetState();

        if (_wasThrown) throw _result;
        return _result;
      });

      return Promise.resolve(_temp3 && _temp3.then ? _temp3.then(function () {}) : void 0);
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.resetState = function resetState() {
    this.activeConnector = null;
    this.accountSubscription = null;
    this.chainIdSubscription = null;
    this.disconnectSubscription = null;
    this.txWeb3.next(null);
    this.account.next(null);
    this.chainId.next(null);
    this.status.next('disconnected');
  };

  _proto.checkOptions = function checkOptions() {
    if (!('httpRpcUrl' in this.options.defaultProvider) && !('wsRpcUrl' in this.options.defaultProvider) && !('infuraAccessToken' in this.options.defaultProvider)) {
      console.error('You need to configure one of these parameters: "httpRpcUrl", "wsRpcUrl" or "infuraAccessToken".');
    }
  };

  _proto.getDefaultProvider = function getDefaultProvider() {
    if ('httpRpcUrl' in this.options.defaultProvider) {
      var _this$options$default = this.options.defaultProvider,
          httpRpcUrl = _this$options$default.httpRpcUrl,
          options = _this$options$default.options;
      return new HttpProvider(httpRpcUrl, options);
    }

    var defaultReconnectOptions = {
      auto: true,
      delay: 5000
    };

    if ('wsRpcUrl' in this.options.defaultProvider) {
      var _this$options$default2 = this.options.defaultProvider,
          wsRpcUrl = _this$options$default2.wsRpcUrl,
          _options = _this$options$default2.options;
      return new WebsocketProvider(wsRpcUrl, _extends({}, _options, {
        reconnect: _extends({}, defaultReconnectOptions, _options === null || _options === void 0 ? void 0 : _options.reconnect)
      }));
    }

    if ('infuraAccessToken' in this.options.defaultProvider) {
      var _this$options$default3 = this.options.defaultProvider,
          infuraAccessToken = _this$options$default3.infuraAccessToken,
          _this$options$default4 = _this$options$default3.network,
          network = _this$options$default4 === void 0 ? 'mainnet' : _this$options$default4,
          _options2 = _this$options$default3.options;
      return new WebsocketProvider("wss://" + network + ".infura.io/ws/v3/" + infuraAccessToken, _extends({}, _options2, {
        reconnect: _extends({}, defaultReconnectOptions, _options2 === null || _options2 === void 0 ? void 0 : _options2.reconnect)
      }));
    }

    return assertNever(this.options.defaultProvider);
  };

  _proto.handleAccountChange = function handleAccountChange(account) {
    this.account.next(account);
  };

  _proto.handleChainIdChange = function handleChainIdChange(chainId) {
    this.chainId.next(chainId);
  };

  _proto.handleDisconnect = function handleDisconnect() {
    this.disconnect();
  };

  return Web3WalletsManager;
}();
function assertNever(value) {
  throw new Error("Unexpected value: " + value);
}

Object.keys(types).forEach(function (k) {
  if (k !== 'default') Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () {
      return types[k];
    }
  });
});
exports.Web3WalletsManager = Web3WalletsManager;
exports.assertNever = assertNever;
//# sourceMappingURL=core.cjs.development.js.map
