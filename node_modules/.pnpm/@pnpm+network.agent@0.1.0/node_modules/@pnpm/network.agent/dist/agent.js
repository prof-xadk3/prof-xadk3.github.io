"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAgent = void 0;
const url_1 = require("url");
const agentkeepalive_1 = __importDefault(require("agentkeepalive"));
const lru_cache_1 = __importDefault(require("lru-cache"));
const network_proxy_agent_1 = require("@pnpm/network.proxy-agent");
const HttpsAgent = agentkeepalive_1.default.HttpsAgent;
const DEFAULT_MAX_SOCKETS = 50;
const AGENT_CACHE = new lru_cache_1.default({ max: 50 });
function getAgent(uri, opts) {
    if ((opts.httpProxy || opts.httpsProxy) && !checkNoProxy(uri, opts)) {
        const proxyAgent = (0, network_proxy_agent_1.getProxyAgent)(uri, opts);
        if (proxyAgent)
            return proxyAgent;
    }
    return getNonProxyAgent(uri, opts);
}
exports.getAgent = getAgent;
function getNonProxyAgent(uri, opts) {
    var _a, _b, _c, _d, _e;
    const parsedUri = new url_1.URL(uri);
    const isHttps = parsedUri.protocol === 'https:';
    /* eslint-disable @typescript-eslint/prefer-nullish-coalescing */
    const key = [
        `https:${isHttps.toString()}`,
        `local-address:${(_a = opts.localAddress) !== null && _a !== void 0 ? _a : '>no-local-address<'}`,
        `strict-ssl:${isHttps ? Boolean(opts.strictSsl).toString() : '>no-strict-ssl<'}`,
        `ca:${(isHttps && ((_b = opts.ca) === null || _b === void 0 ? void 0 : _b.toString())) || '>no-ca<'}`,
        `cert:${(isHttps && ((_c = opts.cert) === null || _c === void 0 ? void 0 : _c.toString())) || '>no-cert<'}`,
        `key:${(isHttps && opts.key) || '>no-key<'}`,
    ].join(':');
    /* eslint-enable @typescript-eslint/prefer-nullish-coalescing */
    if (AGENT_CACHE.peek(key)) {
        return AGENT_CACHE.get(key);
    }
    // If opts.timeout is zero, set the agentTimeout to zero as well. A timeout
    // of zero disables the timeout behavior (OS limits still apply). Else, if
    // opts.timeout is a non-zero value, set it to timeout + 1, to ensure that
    // the node-fetch-npm timeout will always fire first, giving us more
    // consistent errors.
    const agentTimeout = typeof opts.timeout !== 'number' || opts.timeout === 0 ? 0 : opts.timeout + 1;
    // NOTE: localAddress is passed to the agent here even though it is an
    // undocumented option of the agent's constructor.
    //
    // This works because all options of the agent are merged with
    // all options of the request:
    // https://github.com/nodejs/node/blob/350a95b89faab526de852d417bbb8a3ac823c325/lib/_http_agent.js#L254
    const agent = isHttps
        ? new HttpsAgent({
            ca: opts.ca,
            cert: opts.cert,
            key: opts.key,
            localAddress: opts.localAddress,
            maxSockets: (_d = opts.maxSockets) !== null && _d !== void 0 ? _d : DEFAULT_MAX_SOCKETS,
            rejectUnauthorized: opts.strictSsl,
            timeout: agentTimeout,
        }) // eslint-disable-line @typescript-eslint/no-explicit-any
        : new agentkeepalive_1.default({
            localAddress: opts.localAddress,
            maxSockets: (_e = opts.maxSockets) !== null && _e !== void 0 ? _e : DEFAULT_MAX_SOCKETS,
            timeout: agentTimeout,
        }); // eslint-disable-line @typescript-eslint/no-explicit-any
    AGENT_CACHE.set(key, agent);
    return agent;
}
function checkNoProxy(uri, opts) {
    const host = new url_1.URL(uri).hostname.split('.').filter(x => x).reverse();
    if (typeof opts.noProxy === 'string') {
        const noproxyArr = opts.noProxy.split(/\s*,\s*/g);
        return noproxyArr.some(no => {
            const noParts = no.split('.').filter(x => x).reverse();
            if (noParts.length === 0) {
                return false;
            }
            for (let i = 0; i < noParts.length; i++) {
                if (host[i] !== noParts[i]) {
                    return false;
                }
            }
            return true;
        });
    }
    return opts.noProxy;
}
//# sourceMappingURL=agent.js.map