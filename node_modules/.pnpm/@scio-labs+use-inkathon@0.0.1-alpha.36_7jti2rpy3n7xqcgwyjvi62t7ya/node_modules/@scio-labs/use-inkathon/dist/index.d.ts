import { InjectedAccountWithMeta } from '@polkadot/extension-inject/types';
import { ApiPromise, WsProvider, HttpProvider } from '@polkadot/api';
import * as _polkadot_api_contract from '@polkadot/api-contract';
import { ContractPromise, Abi } from '@polkadot/api-contract';
import * as _polkadot_api_contract_types from '@polkadot/api-contract/types';
import { ContractOptions, ContractCallOutcome } from '@polkadot/api-contract/types';
import * as _polkadot_types_interfaces from '@polkadot/types/interfaces';
import { EventRecord, ContractExecResult, AccountId, WeightV2 } from '@polkadot/types/interfaces';
import { IKeyringPair, ISubmittableResult, Callback, Signer } from '@polkadot/types/types';
import { BN } from '@polkadot/util';
import { ApiOptions } from '@polkadot/api/types';
import * as react from 'react';
import { Dispatch, SetStateAction, PropsWithChildren, FC } from 'react';

/**
 * Substrate Chain Type
 */
interface SubstrateChain {
    network: string;
    name: string;
    rpcUrls: [string, ...string[]];
    ss58Prefix?: number;
    explorerUrls?: string[];
    testnet?: boolean;
    faucetUrls?: string[];
}
/**
 * Defined Substrate Chain Constants
 */
declare const development: SubstrateChain;
declare const alephzeroTestnet: SubstrateChain;
declare const rococo: SubstrateChain;
declare const astar: SubstrateChain;
declare const shiden: SubstrateChain;
declare const shibuya: SubstrateChain;
/**
 * Exporting all chains separately
 */
declare const allSubstrateChains: SubstrateChain[];
/**
 * Returns chain (if existent) for given identifier (`network` field).
 */
declare const getSubstrateChain: (networkId?: string) => SubstrateChain | undefined;

/**
 * Returns true if both given injected accounts have the same address.
 */
declare const accountsAreEqual: (a1?: InjectedAccountWithMeta, a2?: InjectedAccountWithMeta) => boolean;
/**
 * Returns true if both given arrays of injected accounts contain the
 * same objects with the same addresses in the same order.
 */
declare const accountArraysAreEqual: (a1: InjectedAccountWithMeta[], a2: InjectedAccountWithMeta[]) => boolean;

/**
 * Performs a dry run for the given contract method and arguments.
 * Is used within `contractQuery` & `contractTx` for gas estimation.
 */
declare const contractCallDryRun: (api: ApiPromise, account: IKeyringPair | string, contract: ContractPromise, method: string, options?: ContractOptions, args?: unknown[]) => Promise<ContractCallOutcome>;
/**
 * Calls a given non-mutating contract method (query) with maximum possible gas limit.
 */
declare const contractQuery: (api: ApiPromise, address: string, contract: ContractPromise, method: string, options?: ContractOptions, args?: unknown[]) => Promise<ContractCallOutcome>;
/**
 * Calls a given mutating contract method (tx) and wraps it in a promise.
 * Before, a dry run is performed to determine the required gas & potential errors.
 */
type ContractTxResult = {
    dryResult: ContractCallOutcome;
    result?: ISubmittableResult;
    errorMessage?: string | 'UserCancelled' | 'ExtrinsicFailed' | 'Error';
    errorEvent?: EventRecord;
};
declare const contractTx: (api: ApiPromise, account: IKeyringPair | string, contract: ContractPromise, method: string, options?: ContractOptions, args?: unknown[], statusCb?: Callback<ISubmittableResult>) => Promise<ContractTxResult>;

/**
 * Decodes & unwraps outputs and errors of a given result, contract, and method.
 * Parsed error message can be found in `decodedOutput` if `isError` is true.
 * SOURCE: https://github.com/paritytech/contracts-ui (GPL-3.0-only)
 */
declare function decodeOutput({ result }: Pick<ContractExecResult, 'result' | 'debugMessage'>, contract: ContractPromise, method: string): {
    output: any;
    decodedOutput: string;
    isError: boolean;
};

/**
 * Uploads & instantiates a contract on-chain.
 */
declare const deployContract: (api: ApiPromise, account: IKeyringPair | string, abi: any, wasm: Uint8Array | string | Buffer, constructorMethod?: string, args?: unknown[], options?: ContractOptions) => Promise<{
    address: string;
    hash: string;
}>;

/**
 * Formats the given `balance` (BN) to a string.
 */
declare const formatBalance: (balance: BN, decimals: number, maxFractionDigits?: number) => string;
/**
 * Formats the given `balance` (BN) to a string with fixed number of decimals.
 */
declare const formatBalanceToFixed: (balance: BN, decimals: number, fractionDigits?: number) => string;

/**
 * Returns the ABI message for the given method name within the given contract.
 */
declare const getAbiMessage: (contract: ContractPromise, method: string) => _polkadot_api_contract_types.AbiMessage;

/**
 * Returns the native token balance of the given `address`.
 */
declare const getBalance: (api: ApiPromise, address: string | AccountId, fractionDigits?: number) => Promise<{
    freeBalance: BN;
    reservedBalance: BN;
    balance: BN;
    balanceFormatted: string;
    tokenSymbol: string;
    tokenDecimals: number;
}>;

/**
 * Helper function that returns Weights V2 `gasLimit` object.
 */
declare const getGasLimit: (api: ApiPromise, _refTime: string | BN, _proofSize: string | BN) => WeightV2;
/**
 * Helper function that returns the maximum gas limit Weights V2 object
 * for an extrinsiv based on the api chain constants.
 * NOTE: It's reduced by a given factor (defaults to 80%) to avoid storage exhaust.
 */
declare const getMaxGasLimit: (api: ApiPromise, reductionFactor?: number) => WeightV2;

/**
 * Helper to initialize polkadot.js API with given chain and options.
 */
declare const initPolkadotJs: (chain: SubstrateChain, options?: ApiOptions) => Promise<{
    api: ApiPromise;
    provider: WsProvider | HttpProvider;
}>;

/**
 * Unwraps a Weights V2 result type or errors if there is no 'ok' value.
 */
declare const unwrapResultOrError: <T = any>(outcome: Pick<ContractCallOutcome, 'result' | 'output'>) => T;
/**
 * Unwraps a Weights V2 result type or returns the given default if there is no 'ok' value.
 */
declare const unwrapResultOrDefault: <T = any>(outcome: Pick<ContractCallOutcome, 'result' | 'output'>, defaultValue: T) => T;

/**
 * Hook that returns the native token balance of the given `address`.
 */
declare const useBalance: (address?: string | AccountId, fractionDigits?: number) => {
    freeBalance: BN | undefined;
    reservedBalance: BN | undefined;
    balance: BN | undefined;
    balanceFormatted: string | undefined;
    tokenSymbol: string | undefined;
    tokenDecimals: number | undefined;
};

/**
 * React Hook that returns a `ContractPromise` object configured with
 * the active api & chain as well as the given `abi` and `address`.
 */
declare const useContract: (abi?: string | Record<string, unknown> | Abi, address?: string | AccountId) => {
    contract: ContractPromise | undefined;
    address: string | AccountId | undefined;
};

/**
 * React Hook that returns a `ContractPromise` object configured with
 * the active api & chain as well as the given deployment contract id
 * which is looked up from the deployments registry.
 */
declare const useRegisteredContract: (contractId: string, networkId?: string) => {
    contract: _polkadot_api_contract.ContractPromise | undefined;
    address: string | _polkadot_types_interfaces.AccountId | undefined;
};

/**
 * Substrate Deployment
 */
interface SubstrateDeployment {
    contractId: string;
    networkId: string;
    abi: string | Record<string, unknown> | Abi;
    address: string | AccountId;
}
/**
 * Registering the given `deployment` with the given `setDeployments` dispatcher.
 * The registry is kept unique, so if there is already one deployment with
 * equal `contractId` and `networkId` it will be replaced.
 */
declare const registerDeployment: (setDeployments: Dispatch<SetStateAction<SubstrateDeployment[]>>, deployment: SubstrateDeployment) => void;
/**
 * Registers all given `deployments` via `registerDeployment` after awaiting the promise.
 */
declare const registerDeployments: (setDeployments: Dispatch<SetStateAction<SubstrateDeployment[]>>, deployments: Promise<SubstrateDeployment[]>) => Promise<void>;
/**
 * Returns the first matching deployment from the given `deployments` array
 * with an equal `contractId` and `networkId`
 */
declare const getDeployment: (deployments: SubstrateDeployment[], contractId: string, networkId: string) => SubstrateDeployment | undefined;
/**
 * Takes the first matching deployment from the given `deployments` array
 * with an equal `contractId` and `networkId` and creates a `ContractPromise`.
 */
declare const getDeploymentContract: (api: ApiPromise, deployments: SubstrateDeployment[], contractId: string, networkId: string) => ContractPromise | undefined;

/**
 * Helper Types
 */
declare enum UseInkathonErrorCode {
    InitializationError = 0,
    NoSubstrateExtensionDetected = 1,
    NoAccountInjected = 2
}
interface UseInkathonError {
    code: UseInkathonErrorCode;
    message: string;
}
/**
 * UseInkathon Context Type
 */
type UseInkathonProviderContextType = {
    isConnecting?: boolean;
    isConnected?: boolean;
    error?: UseInkathonError;
    activeChain?: SubstrateChain;
    switchActiveChain?: (chain: SubstrateChain) => Promise<void>;
    api?: ApiPromise;
    provider?: WsProvider | HttpProvider;
    connect?: () => Promise<void>;
    disconnect?: () => void;
    accounts?: InjectedAccountWithMeta[];
    activeAccount?: InjectedAccountWithMeta;
    activeSigner?: Signer;
    setActiveAccount?: Dispatch<SetStateAction<InjectedAccountWithMeta | undefined>>;
    deployments?: SubstrateDeployment[];
};
declare const UseInkathonProviderContext: react.Context<UseInkathonProviderContextType | null>;
/**
 * Primary useInkathon hook that exposes `UseInkathonProviderContext`.
 */
declare const useInkathon: () => UseInkathonProviderContextType;
/**
 * Primary useInkathon provider that needs to be wrapped around the app
 * (see documentation) to use `useInkathon` and other hooks anywhere.
 */
interface UseInkathonProviderProps extends PropsWithChildren {
    appName: string;
    defaultChain: SubstrateChain | SubstrateChain['network'];
    connectOnInit?: boolean;
    deployments?: Promise<SubstrateDeployment[]>;
    apiOptions?: ApiOptions;
}
declare const UseInkathonProvider: FC<UseInkathonProviderProps>;

/**
 * Substrate Wallet Type(s)
 */
interface SubstrateWallet {
    id: string;
    name: string;
    platforms: [SubstrateWalletPlatform, ...SubstrateWalletPlatform[]];
    urls: {
        website: string;
        chromeExtension?: string;
        firefoxExtension?: string;
        iosApp?: string;
        androidApp?: string;
    };
    logoUrls: [string, ...string[]];
}
declare enum SubstrateWalletPlatform {
    Browser = "browser",
    Android = "android",
    iOS = "ios"
}
/**
 * Defined Substrate Wallet Constants
 */
declare const polkadotjs: SubstrateWallet;
declare const subwallet: SubstrateWallet;
declare const talisman: SubstrateWallet;
declare const nova: SubstrateWallet;
/**
 * Exporting all wallets separately
 */
declare const allSubstrateWallets: SubstrateWallet[];
/**
 * Returns wallet (if existent) for given identifier (`id` field).
 */
declare const getSubstrateWallet: (id: string) => SubstrateWallet | undefined;

export { ContractTxResult, SubstrateChain, SubstrateDeployment, SubstrateWallet, SubstrateWalletPlatform, UseInkathonError, UseInkathonErrorCode, UseInkathonProvider, UseInkathonProviderContext, UseInkathonProviderContextType, UseInkathonProviderProps, accountArraysAreEqual, accountsAreEqual, alephzeroTestnet, allSubstrateChains, allSubstrateWallets, astar, contractCallDryRun, contractQuery, contractTx, decodeOutput, deployContract, development, formatBalance, formatBalanceToFixed, getAbiMessage, getBalance, getDeployment, getDeploymentContract, getGasLimit, getMaxGasLimit, getSubstrateChain, getSubstrateWallet, initPolkadotJs, nova, polkadotjs, registerDeployment, registerDeployments, rococo, shibuya, shiden, subwallet, talisman, unwrapResultOrDefault, unwrapResultOrError, useBalance, useContract, useInkathon, useRegisteredContract };
