import { Bot, Interaction, Message, User } from "../../deps.js";
import { BotWithProxyCache, ProxyCacheTypes } from "../cache-with-proxy/mod.js";
import { AmethystEventHandler } from "../classes/AmethystEvents.js";
import CategoryClass from "../classes/Category.js";
import { CommandClass } from "../classes/Command.js";
import { Context } from "../classes/Context.js";
import { CategoryOptions } from "../types/categoryOptions.js";
import { CommandOptions } from "../types/commandOptions.js";
import { AmethystCollection } from "../utils/AmethystCollection.js";
import { Async } from "../utils/types.js";
import { AmethystReaction, ComponentCollector, ComponentCollectorOptions, MessageCollector, MessageCollectorOptions, ReactionCollector, ReactionCollectorOptions } from "./collectors.js";
import { CommandCooldown } from "./command.js";
import { AmethystError } from "./errors.js";
import { AmethystEvents } from "./event.js";
import { AmethystTask } from "./tasks.js";
interface runningTasks {
    initialTimeouts: number[];
    intervals: number[];
}
/**An extended version of BotWithCache with a command handler and extra utils*/
export type AmethystBot<B extends Omit<BotWithProxyCache<ProxyCacheTypes, Bot>, "events"> = Omit<BotWithProxyCache<ProxyCacheTypes, Bot>, "events">> = B & AmethystProps & {
    amethystUtils: AmethystUtils;
};
interface AmethystUtils {
    awaitComponent(messageId: bigint, options?: ComponentCollectorOptions & {
        maxUsage?: 1;
    }): Promise<Interaction>;
    awaitComponent(messageId: bigint, options?: ComponentCollectorOptions & {
        maxUsage?: number;
    }): Promise<Interaction[]>;
    awaitComponent(messageId: bigint, options?: ComponentCollectorOptions): Promise<Interaction>;
    awaitReaction(messageId: bigint, options?: ReactionCollectorOptions & {
        maxUsage?: 1;
    }): Promise<AmethystReaction>;
    awaitReaction(messageId: bigint, options?: ReactionCollectorOptions & {
        maxUsage?: number;
    }): Promise<AmethystReaction[]>;
    awaitReaction(messageId: bigint, options?: ReactionCollectorOptions): Promise<AmethystReaction>;
    awaitMessage(memberId: bigint, channelId: bigint, options?: MessageCollectorOptions & {
        maxUsage?: 1;
    }): Promise<Message>;
    awaitMessage(memberId: bigint, channelId: bigint, options?: MessageCollectorOptions & {
        maxUsage?: number;
    }): Promise<Message[]>;
    awaitMessage(memberId: bigint, channelId: bigint, options?: MessageCollectorOptions): Promise<Message>;
    createCommand(command: CommandOptions): void;
    createCategory(category: CategoryOptions): void;
    updateCategory(category: CategoryOptions): void;
    createTask(task: AmethystTask): void;
    clearTasks(): void;
    createInhibitor<T extends CommandClass = CommandClass>(name: string, inhibitor: (bot: AmethystBot, command: T, options?: Context) => Promise<true | AmethystError>): void;
    deleteInhibitor(name: string): void;
    updateSlashCommands(): void;
}
interface AmethystProps extends Omit<BotWithProxyCache<ProxyCacheTypes, Bot>, "events"> {
    user: User;
    events: AmethystEvents;
    messageCollectors: AmethystCollection<string, MessageCollector>;
    componentCollectors: AmethystCollection<bigint, ComponentCollector>;
    reactionCollectors: AmethystCollection<bigint, ReactionCollector>;
    runningTasks: runningTasks;
    tasks: AmethystCollection<string, AmethystTask>;
    category: AmethystCollection<string, CategoryClass>;
    inhibitors: AmethystCollection<string, <T extends CommandClass = CommandClass>(bot: AmethystBot, command: T, options: Context) => Promise<true | AmethystError>>;
    owners?: bigint[];
    botMentionAsPrefix?: boolean;
    prefixCaseSensitive?: boolean;
    defaultCooldown?: CommandCooldown;
    ignoreCooldown?: bigint[];
    guildOnly?: boolean;
    messageQuotedArguments?: boolean;
    ignoreBots?: boolean;
    dmOnly?: boolean;
    eventHandler: AmethystEventHandler;
    extras: any;
    prefix?: string | string[] | ((bot: AmethystBot, message: Message) => Async<string | string[]>);
    on(name: string, callback: (...args: any) => unknown): void;
    once(name: string, callback: (...args: any) => unknown): void;
    emit(name: string, ...args: any[]): void;
}
export {};
