"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.awaitMessage = exports.awaitReaction = exports.awaitComponent = void 0;
async function awaitComponent(bot, messageId, options) {
    const interactions = await collectComponents(bot, {
        key: messageId,
        createdAt: Date.now(),
        filter: options?.filter || (() => true),
        maxUsage: options?.maxUsage || 1,
        timeout: options?.timeout || 1000 * 60 * 15,
    });
    return (options?.maxUsage || 1) > 1 ? interactions : interactions[0];
}
exports.awaitComponent = awaitComponent;
function collectComponents(bot, options) {
    return new Promise((resolve, reject) => {
        bot.componentCollectors
            .get(options.key)
            ?.reject("A new collector began before the user responded to the previous one.");
        bot.componentCollectors.set(options.key, {
            ...options,
            components: [],
            resolve,
            reject,
        });
    });
}
async function awaitReaction(bot, messageId, options) {
    const reactions = await collectReactions(bot, {
        key: messageId,
        createdAt: Date.now(),
        filter: options?.filter || (() => true),
        maxUsage: options?.maxUsage || 1,
        timeout: options?.timeout || 1000 * 60 * 15,
    });
    return (options?.maxUsage || 1) > 1 ? reactions : reactions[0];
}
exports.awaitReaction = awaitReaction;
function collectReactions(bot, options) {
    return new Promise((resolve, reject) => {
        bot.reactionCollectors
            .get(options.key)
            ?.reject("A new collector began before the user responded to the previous one.");
        bot.reactionCollectors.set(options.key, {
            ...options,
            reactions: [],
            resolve,
            reject,
        });
    });
}
async function awaitMessage(bot, memberId, channelId, options) {
    const messages = await collectMessages(bot, {
        key: `${memberId}-${channelId}`,
        channelId,
        createdAt: Date.now(),
        filter: options?.filter || (() => true),
        maxUsage: options?.maxUsage || 1,
        timeout: options?.timeout || 1000 * 60 * 15,
    });
    return (options?.maxUsage || 1) > 1 ? messages : messages[0];
}
exports.awaitMessage = awaitMessage;
function collectMessages(bot, options) {
    return new Promise((resolve, reject) => {
        bot.messageCollectors
            .get(options.key)
            ?.reject("A new collector began before the user responded to the previous one.");
        bot.messageCollectors.set(options.key, {
            ...options,
            messages: [],
            resolve,
            reject,
        });
    });
}
