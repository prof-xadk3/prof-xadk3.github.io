"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const mod_js_1 = require("../../mod.js");
const Validations_js_1 = require("./Validations.js");
/* Exporting the class Category. */
class CategoryClass {
    /**
     * It's a constructor for the Category class
     * @param {CategoryOptions} options - CategoryOptions
     */
    constructor(options) {
        /* Name of the category */
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /* Information about the category */
        Object.defineProperty(this, "description", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /* Treat each command as a subcommand or a command on its own. */
        Object.defineProperty(this, "uniqueCommands", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /* Default command when uniqueCommand is false. */
        Object.defineProperty(this, "default", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /* Commands belonging to this category */
        Object.defineProperty(this, "commands", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.name = options.name;
        this.description = options.description;
        this.uniqueCommands = options.uniqueCommands;
        this.default = options.default;
        this.commands = new mod_js_1.AmethystCollection();
        (0, Validations_js_1.validateRequiredParameters)(this.name, this.description, []);
    }
    /**
     * It takes an object with the same properties as the class, and updates the class with the values of
     * the object
     * @param {CategoryOptions} options - CategoryOptions
     */
    update(options) {
        this.name = options.name;
        this.description = options.description;
        this.uniqueCommands = options.uniqueCommands;
        this.default = options.default;
    }
    /**
     * This function takes the commands that are in the scope of the guild and returns them as an object.
     * @returns The return is a CreateApplicationCommand.
     */
    toGuildApplicationCommand() {
        return {
            name: this.name,
            description: this.description,
            options: this.commands
                .filter((e) => e.scope == "guild")
                .map((e) => e.toApplicationCommand())
                .filter((n) => {
                return n.type > 0;
            }),
        };
    }
    /**
     * It takes a list of commands, filters out the ones that are not global, then maps them to an
     * application command, then filters out the ones that are not of type 0.
     * I'm not sure what the options is, but I'm guessing it's an array.
     * @returns The return value is an object with the name, description, and options properties.
     */
    toApplicationCommand() {
        return {
            name: this.name,
            description: this.description,
            options: this.commands
                .filter((e) => e.scope == "global")
                .map((e) => e.toApplicationCommand())
                .filter((n) => {
                return n.type > 0;
            }),
        };
    }
    /**
     * If the command is unique, return the command if it's name matches the command name and it's type
     * is message. If the command is not unique, return the command if it's name matches the command name
     * and it's type is message. If the command is not unique, return the command if it's name matches
     * the subcommand name and it's type is message.
     * @param {string} commandName - The name of the command you want to get.
     * @param {string} [subCommandName] - The name of the subcommand.
     * @returns The command that is being returned is the command that is being called.
     */
    getCommand(commandName, subCommandName) {
        if (this.uniqueCommands) {
            for (let i = 0; i < this.commands.size; i++)
                if (this.commands.at(i).name == commandName &&
                    this.commands.at(i)?.commandType.includes("message"))
                    return { command: this.commands.at(i), usedSubCommand: true };
        }
        else {
            if (this.name == commandName) {
                for (let i = 0; i < this.commands.size; i++) {
                    if (subCommandName)
                        if ((this.commands.at(i).name == subCommandName.trim() || this.commands.at(i).aliases.includes(subCommandName.trim())) &&
                            this.commands.at(i)?.commandType.includes("message"))
                            return {
                                command: this.commands.at(i),
                                usedSubCommand: true
                            };
                }
                return {
                    command: this.commands.get(this.default), usedSubCommand: false
                };
            }
        }
        return {
            usedSubCommand: true
        };
    }
    /**
     * If the command name is the same as the command name passed in, then check if the subcommand name
     * is the same as the subcommand name passed in, if it is, return the command, if it isn't, check if
     * the command name is the same as the subcommand name passed in, if it is, return the command, if it
     * isn't, return undefined.
     * @param {string} commandName - The name of the command you want to get.
     * @param {string} [subCommandName] - The name of the subcommand.
     * @returns a Command or undefined.
     */
    getCommandFromInteraction(commandName, subCommandName) {
        if (this.name == commandName) {
            for (let i = 0; i < this.commands.size; i++) {
                if (subCommandName)
                    for (let i = 0; i < this.commands.size; i++)
                        if (this.commands.at(i).name == commandName &&
                            this.commands.at(i)?.commandType.includes("application"))
                            return this.commands.at(i);
                        else
                            for (let i = 0; i < this.commands.size; i++)
                                if (this.commands.at(i).name == subCommandName &&
                                    this.commands.at(i)?.commandType.includes("application"))
                                    return this.commands.at(i);
            }
        }
        return undefined;
    }
}
exports.default = CategoryClass;
