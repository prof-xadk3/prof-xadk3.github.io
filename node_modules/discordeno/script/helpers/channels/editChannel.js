"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.editChannel = void 0;
const dntShim = __importStar(require("../../_dnt.shims.js"));
/**
 * Edits a channel's settings.
 *
 * @param bot - The bot instance to use to make the request.
 * @param channelId - The ID of the channel to edit.
 * @param options - The parameters for the edit of the channel.
 * @returns An instance of the edited {@link Channel}.
 *
 * @remarks
 * If editing a channel of type {@link ChannelTypes.GroupDm}:
 * - Fires a _Channel Update_ gateway event.
 *
 * If editing a thread channel:
 * - Requires the `MANAGE_THREADS` permission __unless__ if setting the `archived` property to `false` when the `locked` property is also `false`, in which case only the `SEND_MESSAGES` permission is required.
 *
 * - Fires a _Thread Update_ gateway event.
 *
 * If editing a guild channel:
 * - Requires the `MANAGE_CHANNELS` permission.
 *
 * - If modifying permission overrides:
 *   - Requires the `MANAGE_ROLES` permission.
 *
 *   - Only permissions the bot user has in the guild or parent channel can be allowed/denied __unless__ the bot user has a `MANAGE_ROLES` permission override in the channel.
 *
 * - If modifying a channel of type {@link ChannelTypes.GuildCategory}:
 *     - Fires a _Channel Update_ gateway event for each child channel impacted in this change.
 * - Otherwise:
 *     - Fires a _Channel Update_ gateway event.
 */
async function editChannel(bot, channelId, options) {
    if (options.name || options.topic) {
        const request = editChannelNameTopicQueue.get(channelId);
        if (!request) {
            // If this hasn't been done before simply add 1 for it
            editChannelNameTopicQueue.set(channelId, {
                channelId: channelId,
                amount: 1,
                // 10 minutes from now
                timestamp: Date.now() + 600000,
                items: [],
            });
        }
        else if (request.amount === 1) {
            // Start queuing future requests to this channel
            request.amount = 2;
            request.timestamp = Date.now() + 600000;
        }
        else {
            return new Promise((resolve, reject) => {
                // 2 have already been used add to queue
                request.items.push({ channelId, options, resolve, reject });
                if (editChannelProcessing)
                    return;
                editChannelProcessing = true;
                processEditChannelQueue(bot);
            });
        }
    }
    const result = await bot.rest.runMethod(bot.rest, "PATCH", bot.constants.routes.CHANNEL(channelId), {
        name: options.name,
        topic: options.topic,
        bitrate: options.bitrate,
        user_limit: options.userLimit,
        rate_limit_per_user: options.rateLimitPerUser,
        position: options.position,
        parent_id: options.parentId === null ? null : options.parentId?.toString(),
        nsfw: options.nsfw,
        type: options.type,
        archived: options.archived,
        auto_archive_duration: options.autoArchiveDuration,
        locked: options.locked,
        invitable: options.invitable,
        permission_overwrites: options.permissionOverwrites
            ? options.permissionOverwrites?.map((overwrite) => ({
                id: overwrite.id.toString(),
                type: overwrite.type,
                allow: overwrite.allow ? bot.utils.calculateBits(overwrite.allow) : null,
                deny: overwrite.deny ? bot.utils.calculateBits(overwrite.deny) : null,
            }))
            : undefined,
        available_tags: options.availableTags
            ? options.availableTags.map((availableTag) => ({
                id: availableTag.id,
                name: availableTag.name,
                moderated: availableTag.moderated,
                emoji_id: availableTag.emojiId,
                emoji_name: availableTag.emojiName,
            }))
            : undefined,
        applied_tags: options.appliedTags?.map((appliedTag) => appliedTag.toString()),
        default_reaction_emoji: options.defaultReactionEmoji
            ? {
                emoji_id: options.defaultReactionEmoji.emojiId,
                emoji_name: options.defaultReactionEmoji.emojiName,
            }
            : undefined,
        default_sort_order: options.defaultSortOrder,
        reason: options.reason,
    });
    return bot.transformers.channel(bot, { channel: result, guildId: bot.transformers.snowflake(result.guild_id) });
}
exports.editChannel = editChannel;
const editChannelNameTopicQueue = new Map();
let editChannelProcessing = false;
function processEditChannelQueue(bot) {
    if (!editChannelProcessing)
        return;
    const now = Date.now();
    editChannelNameTopicQueue.forEach(async (request) => {
        bot.events.debug(`Running forEach loop in edit_channel file.`);
        if (now < request.timestamp)
            return;
        // 10 minutes have passed so we can reset this channel again
        if (!request.items.length) {
            return editChannelNameTopicQueue.delete(request.channelId);
        }
        request.amount = 0;
        // There are items to process for this request
        const details = request.items.shift();
        if (!details)
            return;
        await bot.helpers
            .editChannel(details.channelId, details.options)
            .then((result) => details.resolve(result))
            .catch(details.reject);
        const secondDetails = request.items.shift();
        if (!secondDetails)
            return;
        await bot.helpers
            .editChannel(secondDetails.channelId, secondDetails.options)
            .then((result) => secondDetails.resolve(result))
            .catch(secondDetails.reject);
        return;
    });
    if (editChannelNameTopicQueue.size) {
        dntShim.setTimeout(() => {
            bot.events.debug(`Running setTimeout in EDIT_CHANNEL file.`);
            processEditChannelQueue(bot);
        }, 60000);
    }
    else {
        editChannelProcessing = false;
    }
}
